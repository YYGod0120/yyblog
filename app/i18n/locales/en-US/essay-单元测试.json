{
  "0": "From the technical sharing session, some of the things I summarized may not be detailed enough or have some errors",
  "1": "Unit testing",
  "2": "It refers to checking and verifying the smallest testable unit in software. For the meaning of a unit in unit testing, it is generally necessary to determine its specific meaning based on the actual situation. For example, in C language, a unit refers to a function, in Java, a unit refers to a class, and in graphical software, it can refer to a window or menu. In general, a unit is the smallest tested functional module that is manually defined. Unit testing is the lowest level of testing activity to be conducted during software development, where independent units of software are tested in isolation from other parts of the program. For the front-end, we can simply divide it into logical unit testing and UI unit testing",
  "3": "Logical Unit Testing",
  "4": "The most important part of logical unit testing is the assertion library. He allows us to call the matchmaker to test a simple function, which can include simple string comparisons, object depth comparisons, and even determining the number of function calls and error capture. The excellence of the assertion library is an important factor in determining the popularity of a unit testing framework.",
  "5": "Assertion style",
  "6": "At present, in front-end single testing frameworks, whether it is built-in or popular assertion libraries such as Chai, the writing styles can be roughly divided into two categories: TDD (Test driven Development) and BDD (Behavior driven Development). The two are in a progressive relationship, with TDD referring to test driven development, where single tests are written first to verify the implementation of business code. BDD, on top of this, is more semantically oriented and similar to explanatory documents. Take Chai as an example, he has a clear writing style.",
  "7": "However, Jest's built-in assertion library currently only has one TDD writing style, which uses expect and matchers to test the tested function and ultimately throws an error through OR.",
  "8": "Chai",
  "9": "As one of the most popular assertion libraries in the industry, its advantages over other assertion libraries are:",
  "10": "Supports both TDD and BDD styles",
  "11": "The assertion API is powerful and easy to use",
  "12": "Error capture hides the internal function stack, making it easier for users to view error messages",
  "13": "Internal implementation",
  "14": "Firstly, Chai defined an assertion object:",
  "15": "There are two important points here, one is the utility function utilit.lag, which can be understood as setting and retrieving private properties (key value pairs) on an instance object to avoid contaminating the original properties on the original object.",
  "16": "Another one is ssfi, which stands for \"Start Stack Function Indicator\". With lockSsfi, Chai can cut out unnecessary function content, such as Chai's internal implementation and some library functions, from the stack trace of errors thrown when a single test function fails the test.",
  "17": "More specific Chai related parts can be found at -> https://lucasfcosta.com/2017/02/17/JavaScript-Errors-and-Stack-Traces.html",
  "18": "Then Chai internally defined three types of assertion chains for different writing styles",
  "19": ":",
  "20": "The assert object is used for TDD writing, which can be directly called or follow various APIs defined internally by chai",
  "21": "foo.should.be.a('string'),foo.should.equal('bar')expect(answer).to.equal(42),expect(answer, 'topic [answer]').to.equal(42);",
  "22": "The writing of 'should' and 'expect' is more semantic and in line with the BDD style. The natural writing style is also more cumbersome than assert. The following is the important API section, which is also a major feature that distinguishes BDD from TDD.",
  "23": "The addProperty function has two main functions. One is to update ssfi based on lockSsfi when defining target access, which is beneficial for stack tracing when users encounter errors. Another approach is to return a new assertion object and implement a chain call for assertions.",
  "24": "In the BDD style, the relevant APIs can be roughly divided into three types: semantic type API, auxiliary type API, and judgment type API. The semantic API, as the name suggests, has little effect, just to make your assertions easier to understand and more semantic when written.",
  "25": "Auxiliary type APIs are generally used in conjunction with logical judgments, such as deep, not, and so on. It has a certain function but is not used as a logical judgment, and generally needs to be used in conjunction with the judgment type API.",
  "26": "The logical judgment type API is the most extensive and important part of the assertion library API, which works in conjunction with auxiliary type APIs to make logical judgments on whether they meet expectations.",
  "27": "Simply put, BDD based single test is a test that combines semantics and logic, which has the advantage of knowing at a glance what the content of the single test is about and helps non developers understand the function being tested. The downside is that it's a bit troublesome to write. The implementation of TDD in Chai is relatively simple, packaging semantic content into an API, similar to encapsulating another layer.",
  "28": "UI component testing",
  "29": "React/Vue Traditional Web Components",
  "30": "A front-end project, in addition to related JS logic, also involves UI rendering, which is sometimes composed of a combination of components, such as a button or an input box. The rendering of these components cannot be achieved solely through simple assertion libraries. Firstly, rendering usually runs on browsers, and node environments do not support operations such as DOM. Therefore, we need to simulate browser environments. There are still many node packages available on the market for simulating browser environments, such as puppeteer, JSDOM, etc. JSDOM is one of the most common tools for simulating browsers for unit testing.",
  "31": "JSDOM is different from puppeteer in that it does not launch a headless browser to simulate a browser environment. Instead, it simulates some APIs such as document and window, as well as some simple events such as click, through JS, and parses the passed HTML string through parse5. Because it is only a lightweight simulation, there are some flaws: it cannot fully simulate network requests such as keyboard and mouse events, fetch/xhr that require polyfill, and cannot calculate CSS styles, etc..",
  "32": "We can create a UI unit test by using Jest in conjunction with Jsdom. Here is a simple example:",
  "33": "Jest defaults to unit testing in the node environment, which can be specified in the config file or written directly at the beginning of the single test file",
  "34": "Secondly, currently the vast majority of web projects are mostly written by frameworks such as React and Vue, and the components written by these frameworks are essentially JavaScript, which still cannot be operated using DOM. Therefore, we can use some tools to further operate, such as, etc. This is a simple example of a single test using Jest in conjunction with a testing library:",
  "35": "What does the test library do? The core part is the render function, which simulates the mounting process of React. With the help of the browser environment implemented by JSDOM, the test library directly mounts your components to the document (you can also customize the mounting object). Through this, you can use its provided query functions to perform unit testing just like operating HTML.",
  "36": "Mini program component",
  "37": "What if it's a mini program component? Taking WeChat mini program as an example, it provides a and to handle single test issues of mini program components. Here is an example of component testing in the official documentation of a WeChat mini program:",
  "38": "From the examples, it can be seen that the implementation approach of component testing in frameworks such as React is essentially the same, which is to convert a component into a custom component instance and simulate the operation through some methods implemented internally in the tool library. However, because mini program components are based on multiple files (wxml, wxss, js, json) rather than a single function/object. So we need an additional load operation - to obtain wxss through the passed path, compile the contents of the wxml file, and then register a component function for j-components, returning a component ID. Then inject styles globally through the render function and create a custom component tree instance, which can be mounted on the parent node for DOM operations and unit testing.",
  "39": "defect",
  "40": "Due to the absence of wx objects in the runtime environment for component testing, some wx APIs are unusable and require users to implement them themselves. Some of the built-in components in wx have not implemented their functions and only perform rendering."
}