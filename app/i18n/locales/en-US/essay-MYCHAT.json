{
  "项目截图": "ScreenShot",
  "技术选型": "Technology",
  "项目亮点": "Highlights",
  "不同语料库的对话：": "Conversations from Different Corpora:",
  "可选择更贴切提问者问题内容的语料库主题，联系上下文，做出切合问题的优质回答。": "Select corpus themes that are more relevant to the questioner's content, relate to the context, and provide high-quality answers that address the question appropriately.",
  "类GPT流的回答：": "GPT-style responses",
  "GPT流式回答与等待，自动转化md格式。": "GPT streaming answer, automatically convert to md format.",
  "优秀的用户体验：": "Excellent USER experience:",
  "无痛刷新，最大程度减少加载，一键导出对话为word，一键删除以及自定义会话标题。": "Painless refresh, minimize loading, one-click to export conversations to word , one-click to delete and customize conversation titles.",
  "实现难点": "Difficulties",
  "核心功能-AI对话": "AI-dialogue",
  "流式对话：": "Streaming conversation:",
  "对于特殊请求：": "For special requests:",
  "因为XHR没法读取post流式数据，所以改用fetch。总所周知，fetch在请求成功发送的时候返回一个内建的Response对象，我们可以通过不同的格式来访问其body。": "Because XHR cannot read post streaming data, Fetch is used instead. As we all know, Fetch returns a built-in Response object when the request is successfully sent, and we can access its body in different formats.",
  "对于普通的get或者post请求，简单采用axios封装进行网络请求。而GPT对话流式数据，axios因为基于XHR没法做到post流式请求，改用fetch进行数据请求。": "For ordinary get or post requests, simply use axios encapsulation to make network requests. As for GPT conversation streaming data, Axios cannot perform post streaming requests based on XHR, so it uses Fetch for data requests instead.",
  "Response的body可以是一个可读的字节数据流": "The body of the Response can be a readable byte data stream",
  "`rep.body.getReader()`就是创建一个`reader`对象锁定该流，调用`read()`方法读取内容。": "`rep.body.getReader()` is to create a `reader` object to lock the stream and call the `read()` method to read the content.",
  "就是创建一个reader对象锁定该流，调用read()方法读取内容。": "Just create a reader object to lock the stream and call the read() method to read the content.",
  "MD格式转化以及打字机样式：": "MD format conversion and typewriter style:",
  "个人博客对于md格式的转化是利用": "Personal blogs use ",
  "转化为html再进一步进行正则匹配改为适配next的tsx": "to convert html from md and use regular matching to adapt to tsx about next",
  "这个库的优点在于底层并非": "The advantage of this library is that the underlying layer is not ",
  "实现，避免了XSS攻击，更安全。同时也支持不同语法高亮库进行code的高亮显示。": "implementation,XSS attacks are avoided and safer. It also supports different syntax highlighting libraries for code highlighting.",
  "不用自己库库手搓": "No need to rub it with your own hands",
  "打字机样式实现的难点在于判断是否正在输出以及正在输出的内容是什么，判断单次输出完毕与否进行下个内容的读取。": "The difficulty in implementing the typewriter style is to determine whether output is being output and what content is being output, and to determine whether a single output is completed or not to read the next content.",
  "isChatting判断是否是当前流式数据，非当前流式数据通过ref进行保存避免多次重新渲染。": "isChatting determines whether it is the current streaming data. Non-current streaming data is saved through ref to avoid repeated re-rendering.",
  "根据isChatting选择是否打字机，控制打字机结束后再重新获取新内容进行渲染。": "Select whether to type a typewriter according to isChatting, and then re-obtain new content for rendering after controlling the typewriter.",
  "实现GPT打字机样式。": "Implement GPT typewriter style.",
  "用户体验:": "Experience",
  "零痛更新：": "No pain Update:",
  "在先前的项目中，对于后台表单数据的增删查改，都是全部依赖数据请求进行页面重新渲染。这样会导致一个用户体验不行，每次数据更新都要再次请求数据进行渲染，网络请求量大，页面加载慢，用户体验不行。": "In previous projects, the addition, deletion, and modification of background form data all relied on data requests for page re-rendering. This will lead to a poor user experience. Every time the data is updated, the data must be requested again for rendering. The network requests are large, the page loads slowly, and the user experience is poor.",
  "于是在这个项目中": "So,here",
  "采用了": "taking",
  "进行全局数据管理，获取数据复制到本地数据，每次数据更新时同时更新本地数据。利用本地数据进行渲染，实现无痛页面更新渲染。": "to carry out global data management, obtain data and copy it to local data, and update local data at the same time every time the data is updated. Use local data for rendering to achieve painless page update rendering.",
  "新对话创建，删除，以及历史会话记录的删除，更新，都是依赖于本地数据而非请求数据。": "The creation and deletion of new conversations, as well as the deletion and update of historical conversation records, all rely on local data rather than request data.",
  "但是这样也会有一定的问题，比如首次请求量大，导致瀑布流等等": "However, this will also have certain problems, such as large first request volume, resulting in waterfall flow, etc.",
  "RSC(react-serve-component)解决了数据渲染问题，因为它采用服务端生成组件绑定数据返回到客户端进进行渲染。": "RSC (react-serve-component) solves the data rendering problem because it uses the server to generate component binding data and return it to the client for rendering.",
  "总结": "Summarize",
  "项目写的比较急，加上一个人开发，所以对一些组件封装不足，基本都写在一起。": "The project was written in a hurry and was developed by one person, so some components were not encapsulated enough and were basically written together.",
  "Typescript也因为项目体积小，开发不规范使用的少。": "Typescript is also rarely used due to the small size of the project and irregular development.",
  "主要还是解决网络请求以及数据处理上的难点，着力于样式以及用户体验": "Mainly to solve the difficulties in network requests and data processing, focusing on style and user experience"
}
