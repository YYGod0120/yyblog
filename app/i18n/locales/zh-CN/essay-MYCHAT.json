{
  "项目截图": "项目截图",
  "技术选型": "技术选型",
  "项目亮点": "项目亮点",
  "不同语料库的对话：": "不同语料库的对话：",
  "可选择更贴切提问者问题内容的语料库主题，联系上下文，做出切合问题的优质回答。": "可选择更贴切提问者问题内容的语料库主题，联系上下文，做出切合问题的优质回答。",
  "类GPT流的回答：": "类GPT流的回答：",
  "GPT流式回答与等待，自动转化md格式。": "GPT流式回答与等待，自动转化md格式。",
  "优秀的用户体验：": "优秀的用户体验：",
  "无痛刷新，最大程度减少加载，一键导出对话为word，一键删除以及自定义会话标题。": "无痛刷新，最大程度减少加载，一键导出对话为word，一键删除以及自定义会话标题。",
  "实现难点": "实现难点",
  "核心功能-AI对话": "核心功能-AI对话",
  "流式对话：": "流式对话：",
  "对于特殊请求：": "对于特殊请求：",
  "因为XHR没法读取post流式数据，所以改用fetch。总所周知，fetch在请求成功发送的时候返回一个内建的Response对象，我们可以通过不同的格式来访问其body。": "因为XHR没法读取post流式数据，所以改用fetch。总所周知，fetch在请求成功发送的时候返回一个内建的Response对象，我们可以通过不同的格式来访问其body。",
  "对于普通的get或者post请求，简单采用axios封装进行网络请求。而GPT对话流式数据，axios因为基于XHR没法做到post流式请求，改用fetch进行数据请求。": "对于普通的get或者post请求，简单采用axios封装进行网络请求。而GPT对话流式数据，axios因为基于XHR没法做到post流式请求，改用fetch进行数据请求。",
  "Response的body可以是一个可读的字节数据流": "Response的body可以是一个可读的字节数据流",
  "`rep.body.getReader()`就是创建一个`reader`对象锁定该流，调用`read()`方法读取内容。": "`rep.body.getReader()`就是创建一个`reader`对象锁定该流，调用`read()`方法读取内容。",
  "就是创建一个reader对象锁定该流，调用read()方法读取内容。": "就是创建一个reader对象锁定该流，调用read()方法读取内容。",
  "MD格式转化以及打字机样式：": "MD格式转化以及打字机样式：",
  "个人博客对于md格式的转化是利用": "个人博客对于md格式的转化是利用",
  "转化为html再进一步进行正则匹配改为适配next的tsx": "转化为html再进一步进行正则匹配改为适配next的tsx",
  "这个库的优点在于底层并非": "这个库的优点在于底层并非",
  "实现，避免了XSS攻击，更安全。同时也支持不同语法高亮库进行code的高亮显示。": "实现，避免了XSS攻击，更安全。同时也支持不同语法高亮库进行code的高亮显示。",
  "不用自己库库手搓": "不用自己库库手搓",
  "打字机样式实现的难点在于判断是否正在输出以及正在输出的内容是什么，判断单次输出完毕与否进行下个内容的读取。": "打字机样式实现的难点在于判断是否正在输出以及正在输出的内容是什么，判断单次输出完毕与否进行下个内容的读取。",
  "isChatting判断是否是当前流式数据，非当前流式数据通过ref进行保存避免多次重新渲染。": "isChatting判断是否是当前流式数据，非当前流式数据通过ref进行保存避免多次重新渲染。",
  "根据isChatting选择是否打字机，控制打字机结束后再重新获取新内容进行渲染。": "根据isChatting选择是否打字机，控制打字机结束后再重新获取新内容进行渲染。",
  "实现GPT打字机样式。": "实现GPT打字机样式。",
  "用户体验:": "用户体验:",
  "零痛更新：": "零痛更新：",
  "在先前的项目中，对于后台表单数据的增删查改，都是全部依赖数据请求进行页面重新渲染。这样会导致一个用户体验不行，每次数据更新都要再次请求数据进行渲染，网络请求量大，页面加载慢，用户体验不行。": "在先前的项目中，对于后台表单数据的增删查改，都是全部依赖数据请求进行页面重新渲染。这样会导致一个用户体验不行，每次数据更新都要再次请求数据进行渲染，网络请求量大，页面加载慢，用户体验不行。",
  "于是在这个项目中": "于是在这个项目中",
  "采用了": "采用了",
  "进行全局数据管理，获取数据复制到本地数据，每次数据更新时同时更新本地数据。利用本地数据进行渲染，实现无痛页面更新渲染。": "进行全局数据管理，获取数据复制到本地数据，每次数据更新时同时更新本地数据。利用本地数据进行渲染，实现无痛页面更新渲染。",
  "新对话创建，删除，以及历史会话记录的删除，更新，都是依赖于本地数据而非请求数据。": "新对话创建，删除，以及历史会话记录的删除，更新，都是依赖于本地数据而非请求数据。",
  "但是这样也会有一定的问题，比如首次请求量大，导致瀑布流等等": "但是这样也会有一定的问题，比如首次请求量大，导致瀑布流等等",
  "RSC(react-serve-component)解决了数据渲染问题，因为它采用服务端生成组件绑定数据返回到客户端进进行渲染。": "RSC(react-serve-component)解决了数据渲染问题，因为它采用服务端生成组件绑定数据返回到客户端进进行渲染。",
  "总结": "总结",
  "项目写的比较急，加上一个人开发，所以对一些组件封装不足，基本都写在一起。": "项目写的比较急，加上一个人开发，所以对一些组件封装不足，基本都写在一起。",
  "Typescript也因为项目体积小，开发不规范使用的少。": "Typescript也因为项目体积小，开发不规范使用的少。",
  "主要还是解决网络请求以及数据处理上的难点，着力于样式以及用户体验": "主要还是解决网络请求以及数据处理上的难点，着力于样式以及用户体验"
}
