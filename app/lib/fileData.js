const data = [
  {
    title: "武汉之行",
    date: "2023-05-03",
    categories: "Life",
    excerpt: "故人西辞黄鹤楼，烟花三月下扬州。孤帆远影碧空尽，唯见长江天际流。",
    html: "<blockquote>\n<p>人真的多多多，酒店真的远远远；希望下次能避开大假期，酒店定的<del>贵一点</del>好一点</p>\n</blockquote>\n<h1>Day1</h1>\n<p>早上八点快九点的动车，5 点钟我就从学校出发了\n昨天买的零食还丢在了车上，硬生生饿七个多小时到武汉</p>\n<Image src={day1_station} alt=\"\" \n      sizes=\"100vw\"\n      style={{\n        width: '100%',\n        height: 'auto',\n      }} />\n人多到 6 点排队吃小龙虾要排上 130 桌，换了一家偏僻角落的店铺才能吃上。\n\n<Image src={feifeixiazhuang} alt=\"肥肥虾庄\" \n      sizes=\"100vw\"\n      style={{\n        width: '100%',\n        height: 'auto',\n      }} />\n\n<p>吃完饭坐上了轮渡，一路坐到长江大桥桥下。</p>\n<Image src={me_girlfriend} alt=\"轮渡上合照一张\" \n      sizes=\"100vw\"\n      style={{\n        width: '100%',\n        height: 'auto',\n      }} />\n\n<p>从船上看长江大桥不如在路上看</p>\n<Image src={bridge0} alt=\"桥头小亭子\" \n      sizes=\"100vw\"\n      style={{\n        width: '100%',\n        height: 'auto',\n      }} />\n<Image src={bridge1} alt=\"长江大桥\" \n      sizes=\"100vw\"\n      style={{\n        width: '100%',\n        height: 'auto',\n      }} />\n\n<h1>Day2</h1>\n<p>来武汉听说不能不过早\n兰陵路离我们酒店算最近的(一样很远)\n武汉本地热干面真的和别的地方的武汉热干面不一样，香太多了。</p>\n<Image src={guozao1} alt=\"热干面，烧卖，绿豆汤\" \n      sizes=\"100vw\"\n      style={{\n        width: '100%',\n        height: 'auto',\n      }} />\n这家三鲜豆皮不好吃\n\n<Image src={guozao2} alt=\"三鲜豆皮\" \n      sizes=\"100vw\"\n      style={{\n        width: '100%',\n        height: 'auto',\n      }} />\n\n<p>下午去了古德寺，和以前去过的寺庙不太一样，带有点欧洲的风格。</p>\n<Image src={gude} alt=\"古德寺\" \n      sizes=\"100vw\"\n      style={{\n        width: '100%',\n        height: 'auto',\n      }} />\n一根 15，还不错的景区特色雪糕\n\n<Image src={gudexuegao} alt=\"古德寺特色雪糕\" \n      sizes=\"100vw\"\n      style={{\n        width: '100%',\n        height: 'auto',\n      }} />\n\n<p>本来打算再去长江大桥上看看日落，低估了我们的行进速度，美美的在路上看着太阳落下。</p>\n<Image src={jianghang} alt=\"路经江汉桥\" \n      sizes=\"100vw\"\n      style={{\n        width: '100%',\n        height: 'auto',\n      }} />\n\n<p>而且今晚的人流量，少说也有昨天的 2 倍。大桥上黑压压的都是人，根本没法走。\n想挤地铁回家，误打误撞挤到户部巷中。\n扭头买个冰粉，直接堵在巷中出都出不来。</p>\n<Image src={day2_night1} alt=\"就扭了个头买冰粉\" \n      sizes=\"100vw\"\n      style={{\n        width: '100%',\n        height: 'auto',\n      }} />\n\n<p>原来这边是拍黄鹤楼的绝美点，难怪挤死了</p>\n<Image src={huanghelou} alt=\"封面来源\" \n      sizes=\"100vw\"\n      style={{\n        width: '100%',\n        height: 'auto',\n      }} />\n\n<h1>Day3</h1>\n<p>早上要换酒店，干脆睡吃一点，在酒店过早了</p>\n<Image src={day3_m} alt=\"锅贴，热干面，绿豆汤米酒和燕麦豆浆\" \n      sizes=\"100vw\"\n      style={{\n        width: '100%',\n        height: 'auto',\n      }} />\n\n<p>下午去东湖，坐地铁转了无数个站，在下午太阳最大的时候来到了东湖\n原来省博和省美术馆也在这里，可惜没预约也进不去</p>\n<Image src={donhu1} alt=\"东湖\" \n      sizes=\"100vw\"\n      style={{\n        width: '100%',\n        height: 'auto',\n      }} />\n<Image src={donhu2} alt=\"屈原纪念馆\" \n      sizes=\"100vw\"\n      style={{\n        width: '100%',\n        height: 'auto',\n      }} />\n<Image src={donhu3} alt=\"美女在东湖\" \n      sizes=\"100vw\"\n      style={{\n        width: '100%',\n        height: 'auto',\n      }} />\n\n<p>挺讨厌吃饭要排队的，但楚采这家店上的快，价格便宜，主要是好吃，特别是虾和红烧肉。\n可惜在五一踩着开门的时间去排队也得等上一个小时。</p>\n<Image src={cha} alt=\"心心念念的茶颜悦色\" \n      sizes=\"100vw\"\n      style={{\n        width: '100%',\n        height: 'auto',\n      }} />\n<Image src={chucai1} alt=\"楚采的红烧肉\" \n      sizes=\"100vw\"\n      style={{\n        width: '100%',\n        height: 'auto',\n      }} />\n<Image src={chucai2} alt=\"楚采的虾\" \n      sizes=\"100vw\"\n      style={{\n        width: '100%',\n        height: 'auto',\n      }} />\n\n<p>吃完去中山公园散个步</p>\n<Image src={zhongshan} alt=\"路过旋转木马\" \n      sizes=\"100vw\"\n      style={{\n        width: '100%',\n        height: 'auto',\n      }} />\n<Image src={together} alt=\"合照\" \n      sizes=\"100vw\"\n      style={{\n        width: '100%',\n        height: 'auto',\n      }} />\n\n<p>四天武汉之行就要结束咯</p>\n<h1>Day4</h1>\n<p>下次车票订一个站，时间差不多，不然分开太痛苦了，又在车站等三个多小时才上车</p>\n<p>回到重庆太晚了，在学长的别墅留宿一晚</p>\n<h1>总结</h1>\n<p>看来我俩旅游不适合特种兵玩法，就喜欢吃吃吃，不喜欢走走走\n酒店别因为便宜就定在鸟不拉屎的地方，啥也没有打车费还高，加上打车费和位置好的酒店价格没差\n人实在太多，大伙疫情关了 3 年，现在刚放开的一个小长假，出行人数简直爆炸，希望下次能避开高峰期</p>\n",
    id: "8",
  },
  {
    title: "TheFirstRedrockProject",
    date: "2023-09-18",
    excerpt: "The First Project,the first step",
    categories: "Project",
    html: '<blockquote>\n<p>第一个团队合作项目</p>\n</blockquote>\n<p>收获：</p>\n<ul>\n<li>git</li>\n<li>团队协作</li>\n</ul>\n<p><a href="http://fe-prod.redrock.cqupt.edu.cn/venue-application-backstage/">项目地址</a></p>\n<h1>技术栈</h1>\n<ol>\n<li>React</li>\n<li>Typescript</li>\n<li>Vite</li>\n<li>Recoil</li>\n<li>ANTD</li>\n<li>Mock</li>\n<li>module.less</li>\n<li>pnpm</li>\n</ol>\n<h1>拆分模块</h1>\n<ol>\n<li><p>其余场地申请</p>\n<ul>\n<li>申请列表</li>\n<li>时间表</li>\n</ul>\n</li>\n<li><p>科技会堂场地申请 - 申请列表 - 时间表</p>\n</li>\n</ol>\n<p>二者差异不大，主要是在一些弹窗以及内容上的区别</p>\n<h1>实现思路</h1>\n<ul>\n<li>申请列表：</li>\n</ul>\n<ol>\n<li>接受后端传的 data，通过 ANTD 渲染表格。</li>\n<li>不同状态的场地的筛选就是对 data 筛选完成为新的 data 通通过 ANTD 渲染。</li>\n<li>搜索同理，注意就是搜索要在不同状态的场地筛选完的新 data 再搜索筛选。</li>\n<li>详情弹窗就是点击详情将这一条数据传递给弹窗组件。</li>\n</ol>\n<ul>\n<li>时间表：</li>\n</ul>\n<ol>\n<li>时间表稍微有难度一点，首先是表格没有使用 ANTD，使用原生的 table 和 tr td 标签</li>\n<li>将每块场地为每一行的行头，将当天的每一段时间作为每一列的列头。</li>\n<li>然后是表格内容的数据的处理，以其余场地申请为例子，是通过日期查询当天的场地申请数据，然后进行数据的处理，将某块场地设为 parent，他全部时间段设为一个 children，里面的每一个 child 通过申请的或者待审批的就是被占用的，flag 为 ture，其余的为 flase，条件渲染到表格中。</li>\n<li>再对每一个表格格子做一点动画，也以其余场地申请为例子，鼠标移入出现编辑图标，移除图标消失，点击图标出现编辑弹窗，传入选中时间以及场地，以及其他需要编辑的表单。</li>\n<li>点击占用的部分，跳出详情弹窗，内容为当前格的数据</li>\n<li>科技会堂申请的时间表有些许不同，每一行的行头是日期，列头也是每段时间，时间段也不同，只用对数据处理做一些修改。</li>\n<li>鼠标移入移除动画也不同，是点击移动相应的表格颜色变化，松开跳出编辑弹窗。</li>\n</ol>\n<p>难点：\n一个在于 ts 的运用，数据类型麻烦且多，需要仔细琢磨不然很容易出错\n二个就是对原生表格的运用，时间表数据的处理也是一大难点</p>\n',
    id: "5",
  },
  {
    title: "长沙之旅",
    date: "2023-10-03",
    categories: "Life",
    excerpt:
      "独立寒秋，湘江北去，橘子洲头。看万山红遍，层林尽染；漫江碧透，百舸争流。鹰击长空，鱼翔浅底，万类霜天竞自由。怅寥廓，问苍茫大地，谁主沉浮？携来百侣曾游。忆往昔峥嵘岁月稠。恰同学少年，风华正茂书生意气，挥斥方遒。指点江山，激扬文字，粪土当年万户侯。曾记否，到中流击水，浪遏飞舟？",
    html: "<blockquote>\n<p>下次记得国庆多呆一天</p>\n</blockquote>\n<h1>day1</h1>\n<p>提前好几天约的师傅不知道是睡过头了还是不想接我这一单，并没有来接我，校门口的黄色法拉利也不见了，只剩下了黑车。一辆车 8 个人，好在价格也没有多离谱，也按时到了火车站</p>\n<p>长沙比武汉近，6 个小时左右，在下午 3 点就到长沙了</p>\n<p>这次吸取武汉的教训，把酒店定在了地铁旁边，还就在高铁站附近</p>\n<Image src={room} alt=\"房间\" \n      sizes=\"100vw\"\n      style={{\n        width: '100%',\n        height: 'auto',\n      }} />\n\n<p>中秋节晚上，五一广场的街上就已经爆满，到处都是网红店的宣传，可能就趁这几天涨涨业绩\n<Image src={jie} alt=\"五一广场\" \n      sizes=\"100vw\"\n      style={{\n        width: '100%',\n        height: 'auto',\n      }} /></p>\n<p>我们还是受不住各自宣传推销,走近了一家网红店吃小龙虾，但是最后选择了罗氏虾\n不过味道实在一般，甚至不如我妈煮的味道。价格却不一般，差不多 4 道菜就花掉 300 大洋\n<Image src={firstdinner} alt=\"靓虾二哥\" \n      sizes=\"100vw\"\n      style={{\n        width: '100%',\n        height: 'auto',\n      }} />\n<Image src={firstdinner2} alt=\"靓虾二哥\" \n      sizes=\"100vw\"\n      style={{\n        width: '100%',\n        height: 'auto',\n      }} />\n<Image src={firstdinner3} alt=\"靓虾二哥\" \n      sizes=\"100vw\"\n      style={{\n        width: '100%',\n        height: 'auto',\n      }} /></p>\n<hr />\n<p>吃完饭，散散步，一路走到杜甫江阁\n路上还被黑心手工艺人骗走 188，留下一幅<del>大众样</del>剪纸\n<Image src={pic} alt=\"188的剪纸\" \n      sizes=\"100vw\"\n      style={{\n        width: '100%',\n        height: 'auto',\n      }} /></p>\n<p>杜甫江阁有专门拍照的的，设备挺齐全，会教我们摆 pose，拍的照片质量高，价格还可以，和剪纸可以说是鲜明对比。</p>\n<p>如果自己有相机，估计也能拍出这样的图\n<Image src={me} alt=\"杜甫江阁\" \n      sizes=\"100vw\"\n      style={{\n        width: '100%',\n        height: 'auto',\n      }} />\n<Image src={love} alt=\"杜甫江阁\" \n      sizes=\"100vw\"\n      style={{\n        width: '100%',\n        height: 'auto',\n      }} /></p>\n<h1>day2</h1>\n<p>俩个人旅游，主打的就是睡到自然醒\n早餐也不可能出酒店吃\n早餐\n<Image src={breakfast} alt=\"10点的早餐\" \n      sizes=\"100vw\"\n      style={{\n        width: '100%',\n        height: 'auto',\n      }} />\n中午逛完博物馆，其实也就看了两个展厅，反正门票不用钱\n直接回酒店吃午餐（外卖）\n午餐\n<Image src={lunch} alt=\"主打的就是丰富\" \n      sizes=\"100vw\"\n      style={{\n        width: '100%',\n        height: 'auto',\n      }} />\n休整一下</p>\n<p>晚上去了杨帆夜市，唯二两顿不在酒店吃的正餐\n全国美食街估计都这个味道，就只是去凑凑热闹\n<Image src={yeshi} alt=\"杨帆夜市\" \n      sizes=\"100vw\"\n      style={{\n        width: '100%',\n        height: 'auto',\n      }} />\n<Image src={yeshi2} alt=\"杨帆夜市\" \n      sizes=\"100vw\"\n      style={{\n        width: '100%',\n        height: 'auto',\n      }} />\n<Image src={yeshi3} alt=\"杨帆夜市\" \n      sizes=\"100vw\"\n      style={{\n        width: '100%',\n        height: 'auto',\n      }} />\n<Image src={tea} alt=\"杨帆夜市\" \n      sizes=\"100vw\"\n      style={{\n        width: '100%',\n        height: 'auto',\n      }} />\n<Image src={milk} alt=\"杨帆夜市\" \n      sizes=\"100vw\"\n      style={{\n        width: '100%',\n        height: 'auto',\n      }} />\n逛完美食街还早，想着去渔人码头又太远，就又绕去五一广场了。\n可惜文和友要排队而且人很多，在外面看了看，和福州的 M17 广场差不了太多，就算了</p>\n<p>夜市没吃饱，少不了夜宵\n<Image src={yexiao1} alt=\"一天四顿\" \n      sizes=\"100vw\"\n      style={{\n        width: '100%',\n        height: 'auto',\n      }} /></p>\n<h1>day3</h1>\n<p>git\n早上出门晚 ，差点进不去橘子洲头,12 点的票，11 点 57 分进去\n<Image src={icecream} alt=\"每个景区都少不了的纪念雪糕，不如武汉的好吃\" \n      sizes=\"100vw\"\n      style={{\n        width: '100%',\n        height: 'auto',\n      }} /></p>\n<Image src={lover_back} alt=\"江边健身道\" \n      sizes=\"100vw\"\n      style={{\n        width: '100%',\n        height: 'auto',\n      }} />\n\n<Image src={laomao} alt=\"青年毛\" \n      sizes=\"100vw\"\n      style={{\n        width: '100%',\n        height: 'auto',\n      }} />\n\n<p>走到腿断掉,果断选择酒店看电影</p>\n<p>晚上的渔人码头，没有想象中的那么好，就是一个靠江边吃小龙虾的地方，甚至不如夜市，如果人多来聚一聚吃个龙虾也不错\n<Image src={seaandyou} alt=\"江边美女\" \n      sizes=\"100vw\"\n      style={{\n        width: '100%',\n        height: 'auto',\n      }} /></p>\n<Image src={ciba} alt=\"加了红糖的糍粑罢了\" \n      sizes=\"100vw\"\n      style={{\n        width: '100%',\n        height: 'auto',\n      }} />\n\n<h1>day4</h1>\n<p>快乐的时光总是很短暂，离别从来都很伤感，四天三夜还是太快</p>\n<p>8 天的假期，应该玩上 5 天 4 夜的</p>\n<Image src={lastlunch} alt=\"最后一顿\" \n      sizes=\"100vw\"\n      style={{\n        width: '100%',\n        height: 'auto',\n      }} />\n\n<hr />\n<p>其实长沙没武汉大，从地铁就能看出来，但我感觉玩的比武汉开心，可能在吃这一方面比上次武汉吃的多得多，基本每一天晚上都吃了夜宵\n靠地铁近，不用每次都打车也省下了一笔交通费</p>\n",
    id: "9",
  },
  {
    title: "交通局",
    date: "2023-10-24",
    categories: "Project",
    excerpt:
      "丰都县交通局,一个缝合了12306，嘀嘀打车，货拉拉的网页应用你敢相信。",
    html: '<h1>丰都县交通局</h1>\n<blockquote>\n<p>记得下次好好评审项目以及拉黑胡*</p>\n</blockquote>\n<p><a href="http://47.108.56.37:8080/">项目地址</a>\n市民端：账 123456 密 123456</p>\n<h2>项目概述</h2>\n<p>一个基本的后台管理，但是内容极其恶心，既要打车又要货拉拉还要 12306 买票</p>\n<p>最恶心的就是没有正规的 12306，都是自己爬的接口用。<del>不会被抓吧</del></p>\n<h2>技术栈</h2>\n<ol>\n<li>React + Vite + arcodesign</li>\n<li>tailwind</li>\n<li>recoil</li>\n<li>moment</li>\n</ol>\n<p>属于是只用上了基本的东西</p>\n<h2>负责模块</h2>\n<ol>\n<li>布局以及侧边栏</li>\n<li>信息栏的用户端以及管理端</li>\n<li>权限管理端</li>\n</ol>\n<h3>侧边栏</h3>\n<p>这个项目采用的是文件路由的方式，类似于 Next.js 的文件路由\n所以通过将文件也就是路由扁平化，递归判断是否为父文件还是子文件来进行侧边栏渲染\n通过权限判断一些选项是否渲染，从而达到隐藏的作用</p>\n<SyntaxHighlighter language="js" style={oneLight} showLineNumbers>{ `\\/\\/\\文\\件\\路\\由\\实\\现\nconst layout\\: Record\\<string\\, FC\\<any\\> \\| null\\> \\= \\{\n  default\\: \\(props\\) \\=\\> \\(\n    \\<Layout\\>\n      \\<\\>\\{props\\.children\\}\\<\\/\\>\n    \\<\\/Layout\\>\n  \\)\\,\n  login\\: \\(props\\) \\=\\> \\<\\>\\{props\\.children\\}\\<\\/\\>\\,\n  systemManage\\: \\(props\\) \\=\\> \\(\n    \\<Layout\\>\n      \\<SystemLayout\\>\\{props\\.children\\}\\<\\/SystemLayout\\>\n    \\<\\/Layout\\>\n  \\)\\,\n  companyManage\\: \\(props\\) \\=\\> \\(\n    \\<Layout\\>\n      \\<CompanyLayout\\>\\{props\\.children\\}\\<\\/CompanyLayout\\>\n    \\<\\/Layout\\>\n  \\)\\,\n\\}\\;\nlayout\\;\nconst routeModule\\: Record\\<number\\, \\(\\) \\=\\> JSX\\.Element\\> \\= import\\.meta\\.glob\\(\n  "\\.\\/routes\\/\\*\\*\\/\\*\\.tsx"\\,\n  \\{\n    eager\\: true\\,\n    import\\: "default"\\,\n  \\}\\,\n\\)\\;\nconst modules \\= Object\\.entries\\(routeModule\\)\\;\nconst pathRegExp \\= \\/\\\\\\.\\\\\\/routes\\(\\.\\*\\)\\.tsx\\/\\;\nconst defaultRoutes\\: RouteObject\\[\\] \\= modules\n  \\.filter\\(\\(\\[path\\]\\) \\=\\> \\!path\\.includes\\("children"\\)\\)\n  \\.map\\(\\(v\\) \\=\\> \\{\n    const \\[path\\, Element\\] \\= v\\;\n    const pathLike \\= path\\.replace\\(pathRegExp\\, "\\$1"\\)\\;\n    let routePath \\= \\/\\\\\\/index\\/\\.test\\(pathLike\\)\n      \\? pathLike\\.replace\\(\\/\\\\\\/index\\/\\, ""\\)\n      \\: pathLike\\;\n    if \\(\\/\\\\\\[\\\\w\\+\\\\\\]\\/\\.test\\(pathLike\\)\\) \\{\n      const slug \\= pathLike\\.replace\\(\\/\\.\\*\\\\\\[\\(\\\\w\\+\\)\\\\\\]\\/\\, "\\$1"\\)\\;\n      routePath \\= pathLike\\.replace\\(\\/\\\\\\[\\\\w\\+\\\\\\]\\/\\, \\`\\:\\$\\{slug\\}\\`\\)\\;\n    \\}\n    \\/\\/ console\\.log\\(path\\.split\\("\\/"\\)\\.filter\\(Boolean\\)\\)\\;\n    const \\[\\, \\, login\\, key\\] \\= path\\.split\\("\\/"\\)\\.filter\\(Boolean\\)\\;\n    let Layout \\= layout\\[key\\]\\;\n    Layout \\?\\?\\= layout\\["default"\\]\\;\n    \\/\\/ console\\.log\\(login\\)\\;\n    if \\(login \\=\\=\\= "login"\\) \\{\n      Layout \\= layout\\["login"\\]\\;\n    \\}\n    const route\\: RouteObject \\= \\{\n      path\\: routePath\\,\n      element\\: Layout \\? \\(\n        \\<Layout\\>\n          \\<Element \\/\\>\n        \\<\\/Layout\\>\n      \\) \\: \\(\n        \\<Element \\/\\>\n      \\)\\,\n      errorElement\\: \\<NotFoundPage \\/\\>\\,\n    \\}\\;\n    return route\\;\n  \\}\\)\\;\nconst childrenRoutes \\= createChildren\\(routeModule\\)\\;\nconst \\{ children \\= \\[\\] \\} \\= childrenToArray\\(childrenRoutes\\)\\;\ndefaultRoutes\\.forEach\\(\\(v1\\) \\=\\> \\{\n  children\\.forEach\\(\\(v2\\) \\=\\> \\{\n    if \\(v1\\.path\\?\\.endsWith\\(v2\\.path\\!\\)\\) v1\\.children \\= v2\\.children\\;\n  \\}\\)\\;\n\\}\\)\\;\nexport const routes\\: RouteObject\\[\\] \\= \\[\\.\\.\\.defaultRoutes\\]\\;\nexport const router \\= createHashRouter\\(routes\\)\\;\n` }</SyntaxHighlighter>\n<SyntaxHighlighter language="js" style={oneLight} showLineNumbers>{ `\\/\\/\\/\\侧\\边\\栏\\渲\\染\nexport default function Side\\(\\) \\{\n  const \\[selectKey\\, setSelectKey\\] \\= useState\\<string\\[\\]\\>\\(\\[\\]\\)\n  function renderMenu\\(\n    routes\\: IRoutes\\[\\]\\,\n    menu\\: MenuType\\,\n    routerFather\\: string\\,\n    isFirstSubmenu\\: boolean\\,\n  \\) \\{\n    return routes\\.map\\(\\(route\\) \\=\\> \\{\n      const key \\= routerFather\n        \\? \\`\\$\\{routerFather\\}\\.\\$\\{route\\.RouterFather\\}\\`\n        \\: \\`menu\\.\\$\\{route\\.RouterFather\\}\\`\\;\n      const path \\= key\n        \\.replace\\(\\/\\^menu\\\\\\.\\/\\, ""\\)\n        \\.split\\("\\."\\)\n        \\.join\\("\\/"\\)\\;\n      if \\(route\\.RoutesChildren\\.length \\> 0\\) \\{\n        \\/\\/ console\\.log\\(route\\.RouterFather\\!\\)\\;\n        return \\(\n          \\<SubMenu\n            style\\=\\{showSystem\\(localStorage\\.getItem\\(\'role\'\\)\\!\\)\\.includes\\(key\\) \\? undefined \\: \\{ display\\: \'none\' \\}\\}\n            key\\=\\{key\\}\n            title\\=\\{\n              isFirstSubmenu \\? \\(\n                \\<div className\\=" flex items\\-center"\\>\n                  \\<div className\\=" w\\-3 h\\-3 bg\\-circle rounded\\-full mr\\-4"\\>\\<\\/div\\>\n                  \\<div className\\=" "\\>\\{menu\\[key\\]\\}\\<\\/div\\>\n                \\<\\/div\\>\n              \\) \\: \\(\n                menu\\[key\\]\n              \\)\n            \\}\n          \\>\n            \\{renderMenu\\(route\\.RoutesChildren as IRoutes\\[\\]\\, menu\\, key\\, false\\)\\}\n          \\<\\/SubMenu\\>\n        \\)\\;\n      \\} else \\{\n        return \\(\n          \\<Menu\\.Item key\\=\\{key\\} style\\=\\{showSystem\\(localStorage\\.getItem\\(\'role\'\\)\\!\\)\\.includes\\(key\\) \\? undefined \\: \\{ display\\: \'none\' \\}\\} onClick\\=\\{\\(\\) \\=\\> \\{\n            setSelectKey\\(\\[key\\]\\)\n          \\}\\}\\>\n            \\<Link to\\=\\{"\\/" \\+ path\\} style\\=\\{\\{ color\\: "\\#424B5E99" \\}\\}\\>\n              \\{menu\\[key\\]\\}\n            \\<\\/Link\\>\n          \\<\\/Menu\\.Item\\>\n        \\)\\;\n      \\}\n    \\}\\)\\;\n  \\}\n  const Routes \\= splitRoutes\\(menu\\)\\;\n  const url \\= useLocation\\(\\)\\;\n  \\/\\/ if\\(url\\.pathname\\.startsWith\\(\'\\/reservation\\/user\'\\)\\)\\{\n  \\/\\/   const key \\= \\[\'menu\\.reservation\\.\'\\]\n  \\/\\/ \\}\n\n\n  return \\(\n    \\<div className\\="text\\-white overflow\\-hidden overflow\\-y\\-scroll hide\\-scrollbar h\\-\\[92vh\\]"\\>\n      \\<Menu\n        className\\=""\n        levelIndent\\=\\{30\\}\n        selectedKeys\\=\\{selectKey\\}\n        defaultOpenKeys\\=\\{url\\.pathname\\.split\\(\'\\/\'\\)\\}\n      \\>\n        \\{renderMenu\\(Routes\\, menu\\, ""\\, true\\)\\}\n      \\<\\/Menu\\>\n    \\<\\/div\\>\n  \\)\\;\n\\}\n` }</SyntaxHighlighter>\n<p>优点：</p>\n<ol>\n<li>方便，不需要编写路由表，只需要创建文件就会自动生成对应路由。</li>\n<li>后期渲染侧边栏的 menu 文件相比路由表配置起来也简单</li>\n</ol>\n<p>缺点：</p>\n<ol>\n<li>文件一创建就会生成路由，先前通过文件渲染侧边栏就会导致不想渲染的子路由也出现在侧边栏。\n解决方案是通过 menu 配置进行筛选渲染，但是如此一来就和配置路由表大差不差。</li>\n</ol>\n<p>总结就是：想使用文件路由，可以直接上手<code>Next.js</code>，能方便很多。加上设置侧边栏也是通过<code>menu.ts</code>来进行配置,倒不如直接使用路由表来渲染</p>\n<p>例子：</p>\n<SyntaxHighlighter language="ts" style={oneLight} showLineNumbers>{ `\\/\\/\\路\\由\\类\\型\ntype Auth \\= \\{\n  resource\\: string \\| RegExp\\;\n  actions\\?\\: string\\[\\]\\;\n\\}\\;\nexport interface AuthParams \\{\n  \\/\\/ \\某\\操\\作\\需\\要\\的\\权\\限\\数\\组\n  requiredPermissions\\?\\: Array\\<Auth\\>\\;\n  \\/\\/ \\是\\否\\需\\要\\满\\足\\一\\个\\即\\可\\，\\即\\是\\或\\还\\是\\且\\。\n  oneOfPerm\\?\\: boolean\\;\n\\}\nexport type IRoute \\= AuthParams \\& \\{\n  name\\: string\\;\n  key\\: string\\;\n  breadcrumb\\?\\: boolean\\;\n  children\\?\\: IRoute\\[\\]\\;\n  hideInMenu\\?\\: boolean\\; \\/\\/ \\是\\否\\在\\菜\\单\\中\\隐\\藏\\子\\路\\由\\，\\为\\了\\实\\现\\某\\些\\三\\级\\路\\由\\不\\展\\示\\在\\菜\\单\\中\\的\\需\\求\n  icon\\?\\: React\\.ForwardRefExoticComponent\\<\n    IconProps \\& React\\.RefAttributes\\<unknown\\>\n  \\>\\;\n\\}\\;\n` }</SyntaxHighlighter>\n<SyntaxHighlighter language="tsx" style={oneLight} showLineNumbers>{ `export const generatePermission \\= \\(level\\: string\\) \\=\\> \\{\n  const actions \\= level \\=\\=\\= "3" \\? \\[\\] \\: \\["\\*"\\]\\;\n  const result \\= \\{\\}\\;\n  routes\\.forEach\\(\\(item\\) \\=\\> \\{\n    if \\(item\\.children\\) \\{\n      item\\.children\\.forEach\\(\\(child\\) \\=\\> \\{\n        result\\[child\\.name\\] \\= actions\\;\n      \\}\\)\\;\n    \\}\n  \\}\\)\\;\n  return result\\;\n\\}\\;\nconst useRoute \\= \\(userPermission\\)\\: \\[IRoute\\[\\]\\, string\\] \\=\\> \\{\n  const filterRoute \\= \\(routes\\: IRoute\\[\\]\\, arr \\= \\[\\]\\)\\: IRoute\\[\\] \\=\\> \\{\n    if \\(\\!routes\\.length\\) \\{\n      return \\[\\]\\;\n    \\}\n    for \\(const route of routes\\) \\{\n      const \\{ requiredPermissions\\, oneOfPerm \\} \\= route\\;\n      let visible \\= true\\;\n      if \\(requiredPermissions\\) \\{\n        visible \\= auth\\(\\{ requiredPermissions\\, oneOfPerm \\}\\, userPermission\\)\\;\n      \\}\n      if \\(\\!visible\\) \\{\n        continue\\;\n      \\}\n      if \\(route\\.children \\&\\& route\\.children\\.length\\) \\{\n        const newRoute \\= \\{ \\.\\.\\.route\\, children\\: \\[\\] \\}\\;\n        filterRoute\\(route\\.children\\, newRoute\\.children\\)\\;\n        if \\(newRoute\\.children\\.length\\) \\{\n          arr\\.push\\(newRoute\\)\\;\n        \\}\n      \\} else \\{\n        arr\\.push\\(\\{ \\.\\.\\.route \\}\\)\\;\n      \\}\n    \\}\n\n    return arr\\;\n  \\}\\;\n  const \\[permissionRoute\\, setPermissionRoute\\] \\= useState\\(routes\\)\\;\n  useEffect\\(\\(\\) \\=\\> \\{\n    const newRoutes \\= filterRoute\\(routes\\)\\;\n    setPermissionRoute\\(newRoutes\\)\\;\n    \\/\\/ eslint\\-disable\\-next\\-line react\\-hooks\\/exhaustive\\-deps\n  \\}\\, \\[userPermission\\]\\)\\;\n\n  const defaultRoute \\= useMemo\\(\\(\\) \\=\\> \\{\n    const first \\= permissionRoute\\[0\\]\\;\n    if \\(first\\) \\{\n      const firstRoute \\= first\\?\\.children\\?\\.\\[0\\]\\?\\.key \\|\\| first\\.key\\;\n      return firstRoute\\;\n    \\}\n    return ""\\;\n  \\}\\, \\[permissionRoute\\]\\)\\;\n\n  return \\[permissionRoute\\, defaultRoute\\]\\;\n\\}\\;\n\nexport default useRoute\\;\n` }</SyntaxHighlighter>\n<SyntaxHighlighter language="tsx" style={oneLight} showLineNumbers>{ `\\/\\/\\渲\\染\nfunction renderRoutes\\(locale\\: \\{ \\[x\\: string\\]\\: any \\}\\) \\{\n  routeMap\\.current\\.clear\\(\\)\\;\n  return function travel\\(_routes\\: IRoute\\[\\]\\, level\\: number\\, parentNode \\= \\[\\]\\) \\{\n    return _routes\\.map\\(\\(route\\) \\=\\> \\{\n      const \\{ breadcrumb \\= true\\, hideInMenu \\} \\= route\\;\n      const iconDom \\= getIcon\\(route\\)\\;\n      const titleDom \\= \\(\n        \\<\\>\n          \\{iconDom\\} \\{locale\\[route\\.name\\] \\|\\| route\\.name\\}\n        \\<\\/\\>\n      \\)\\;\n      routeMap\\.current\\.set\\(\n        \\`\\/\\$\\{route\\.key\\}\\`\\,\n        breadcrumb \\? \\[\\.\\.\\.parentNode\\, route\\.name\\] \\: \\[\\]\n      \\)\\;\n      const visibleChildren \\= \\(route\\.children \\|\\| \\[\\]\\)\\.filter\\(\\(child\\) \\=\\> \\{\n        const \\{ hideInMenu\\, breadcrumb \\= true \\} \\= child\\;\n        if \\(hideInMenu \\|\\| route\\.hideInMenu\\) \\{\n          routeMap\\.current\\.set\\(\n            \\`\\/\\$\\{child\\.key\\}\\`\\,\n            breadcrumb \\? \\[\\.\\.\\.parentNode\\, route\\.name\\, child\\.name\\] \\: \\[\\]\n          \\)\\;\n        \\}\n        return \\!hideInMenu\\;\n      \\}\\)\\;\n      \\/\\/ console\\.log\\(visibleChildren\\)\\;\n      if \\(hideInMenu\\) \\{\n        return \\[\\]\\;\n      \\}\n      if \\(visibleChildren\\.length\\) \\{\n        return \\(\n          \\<SubMenu key\\=\\{route\\.key\\} title\\=\\{titleDom\\}\\>\n            \\{travel\\(visibleChildren\\, level \\+ 1\\, \\[\\.\\.\\.parentNode\\, route\\.name\\]\\)\\}\n          \\<\\/SubMenu\\>\n        \\)\\;\n      \\}\n      return \\(\n        \\<MenuItem key\\=\\{route\\.key\\}\\>\n          \\<Link to\\=\\{\\`\\/\\$\\{route\\.key\\}\\`\\}\\>\\{titleDom\\}\\<\\/Link\\>\n        \\<\\/MenuItem\\>\n      \\)\\;\n    \\}\\)\\;\n  \\}\\;\n\\}\n` }</SyntaxHighlighter>\n<p>通过配置路由，可以分权配置，细分到页面和操作，适用于大型的后台管理</p>\n<p>直接通过文件配置路由，适用于简单的后台，不需要配置路由表的情况下，用起来方便\n当然你可以自己选择 Next.js</p>\n<p><del>鄙人浅显的见解，大佬轻喷</del></p>\n<h3>剩下两个模块</h3>\n<p>简单的表格组件使用而已，没什么亮点</p>\n<h2>收获</h2>\n<p>对这种路由布局理解提高了一点\n帮他们写 12306 的时候，学会了抓包工具 Fiddler Classic。<del>说不定哪天能写一个有趣的东西</del></p>\n',
    id: "6",
  },
  {
    title: "React-Design-Patterns",
    date: "2023-11-18",
    excerpt: "React 设计模式(译)",
    categories: "Techology",
    html: '<p>React 设计模式(译)</p>\n<p><a href="https://dev.to/refine/react-design-patterns-230o">原文链接</a></p>\n<h1>介绍</h1>\n<p>React 开发人员可以通过使用设计模式来节省时间和精力，这些模式提供了一种使用经过测试和信任的解决方案解决问题的快速方法。它们使内聚模块具有较低的耦合性，这反过来又帮助 React 开发人员创建可维护、可扩展和高效的应用程序。在本文中，我们将探讨 React 设计模式，并研究它们如何改进 React 应用程序的开发。</p>\n<h1>容器和表示模式</h1>\n<p>容器和表示模式是一种模式，旨在将表示逻辑与反应代码中的业务逻辑分离，从而使其模块化、可测试，并遵循关注分离原则。\n大多数情况下，在 react 应用程序中，我们需要从后端/存储中获取数据或计算逻辑，并在 react 组件上表示该计算的结果。在这些情况下，容器和表示模式大放异彩，因为它可用于将组件分为两个，即：</p>\n<ul>\n<li>容器组件，充当负责数据提取或计算的组件。</li>\n<li>表示组件，其工作是在 UI（用户界面）上呈现获取的数据或计算值。</li>\n</ul>\n<SyntaxHighlighter language="tsx" style={oneLight} showLineNumbers>{ `\\/\\/Container\\.tsx\nimport React\\, \\{ useEffect \\} from "react"\\;\nimport CharacterList from "\\.\\/CharacterList"\\;\n\nconst StarWarsCharactersContainer\\: React\\.FC \\= \\(\\) \\=\\> \\{\n  const \\[characters\\, setCharacters\\] \\= useState\\<Character\\>\\(\\[\\]\\)\\;\n  const \\[isLoading\\, setIsLoading\\] \\= useState\\<boolean\\>\\(false\\)\\;\n  const \\[error\\, setError\\] \\= useState\\<boolean\\>\\(false\\)\\;\n\n  const getCharacters \\= async \\(\\) \\=\\> \\{\n    setIsLoading\\(true\\)\\;\n    try \\{\n      const response \\= await fetch\\(\n        "https\\:\\/\\/akabab\\.github\\.io\\/starwars\\-api\\/api\\/all\\.json"\n      \\)\\;\n      const data \\= await response\\.json\\(\\)\\;\n      setIsLoading\\(false\\)\\;\n      if \\(\\!data\\) return\\;\n      setCharacters\\(data\\)\\;\n    \\} catch \\(err\\) \\{\n      setError\\(true\\)\\;\n    \\} finally \\{\n      setIsLoading\\(true\\)\\;\n    \\}\n  \\}\\;\n\n  useEffect\\(\\(\\) \\=\\> \\{\n    getCharacters\\(\\)\\;\n  \\}\\, \\[\\]\\)\\;\n\n  return \\(\n    \\<CharacterList loading\\=\\{loading\\} error\\=\\{error\\} characters\\=\\{characters\\} \\/\\>\n  \\)\\;\n\\}\\;\n\nexport default StarWarsCharactersContainer\\;\n` }</SyntaxHighlighter>\n<SyntaxHighlighter language="tsx" style={oneLight} showLineNumbers>{ `\\/\\/the component is responsible for displaying the characters\nimport React from "react"\\;\nimport \\{ Character \\} from "\\.\\/types"\\;\n\ninterface CharacterListProps \\{\n  loading\\: boolean\\;\n  error\\: boolean\\;\n  users\\: Character\\[\\]\\;\n\\}\n\nconst CharacterList\\: React\\.FC\\<CharacterListProps\\> \\= \\(\\{\n  loading\\,\n  error\\,\n  characters\\,\n\\}\\) \\=\\> \\{\n  if \\(loading \\&\\& \\!error\\) return \\<div\\>Loading\\.\\.\\.\\<\\/div\\>\\;\n  if \\(\\!loading \\&\\& error\\)\n    return \\<div\\>error occured\\.unable to load characters\\<\\/div\\>\\;\n  if \\(\\!characters\\) return null\\;\n\n  return \\(\n    \\<ul\\>\n      \\{characters\\.map\\(\\(user\\) \\=\\> \\(\n        \\<li key\\=\\{user\\.id\\}\\>\\{user\\.name\\}\\<\\/li\\>\n      \\)\\)\\}\n    \\<\\/ul\\>\n  \\)\\;\n\\}\\;\n\nexport default CharacterList\\;\n` }</SyntaxHighlighter>\n<h1>带有 Hooks 的组件组合</h1>\n<p>钩子是 React 16.8 中首次亮相的全新功能。从那时起，他们在开发 react 应用程序方面发挥了至关重要的作用。钩子是基本函数，用于授予功能组件对状态和生命周期方法的访问权限（以前仅供类组件使用）。另一方面，钩子可以专门设计来满足组件要求并具有其他用例。\n现在，我们可以隔离所有有状态逻辑（一种需要反应式状态变量的逻辑），并使用自定义钩子在组件中编写或使用它。因此，代码更加模块化和可测试，因为钩子松散地绑定在组件上，因此可以单独测试。\n下面显示了带有钩子的组件组合示例：</p>\n<SyntaxHighlighter language="tsx" style={oneLight} showLineNumbers>{ `\\/\\/ creating a custom hook that fetches star wars characters\nexport const useFetchStarWarsCharacters \\= \\(\\) \\=\\> \\{\n  const \\[characters\\, setCharacters\\] \\= useState\\<Character\\>\\(\\[\\]\\)\\;\n  const \\[isLoading\\, setIsLoading\\] \\= useState\\(false\\)\\;\n  const \\[error\\, setError\\] \\= useState\\(false\\)\\;\n  const controller \\= new AbortController\\(\\)\\;\n\n  const getCharacters \\= async \\(\\) \\=\\> \\{\n    setIsLoading\\(true\\)\\;\n    try \\{\n      const response \\= await fetch\\(\n        "https\\:\\/\\/akabab\\.github\\.io\\/starwars\\-api\\/api\\/all\\.json"\\,\n        \\{\n          method\\: "GET"\\,\n          credentials\\: "include"\\,\n          mode\\: "cors"\\,\n          headers\\: \\{\n            "Content\\-Type"\\: "application\\/json"\\,\n            "Access\\-Control\\-Allow\\-Origin"\\: "\\*"\\,\n          \\}\\,\n          signal\\: controller\\.signal\\,\n        \\}\n      \\)\\;\n      const data \\= await response\\.json\\(\\)\\;\n      setIsLoading\\(false\\)\\;\n      if \\(\\!data\\) return\\;\n      setCharacters\\(data\\)\\;\n    \\} catch \\(err\\) \\{\n      setError\\(true\\)\\;\n    \\} finally \\{\n      setIsLoading\\(true\\)\\;\n    \\}\n  \\}\\;\n\n  useEffect\\(\\(\\) \\=\\> \\{\n    getCharacters\\(\\)\\;\n    return \\(\\) \\=\\> \\{\n      controller\\.abort\\(\\)\\;\n    \\}\\;\n  \\}\\, \\[\\]\\)\\;\n\n  return \\[characters\\, isLoading\\, error\\]\\;\n\\}\\;\n` }</SyntaxHighlighter>\n<p>创建自定义钩子后，我们会将其导入到我们的 StarWarsCharactersContainer 组件中并使用它:</p>\n<SyntaxHighlighter language="tsx" style={oneLight} showLineNumbers>{ `\\/\\/ importing the custom hook to a component and fetch the characters\n\nimport React from "react"\\;\nimport \\{ Character \\} from "\\.\\/types"\\;\nimport \\{ useFetchStarWarsCharacters \\} from "\\.\\/useFetchStarWarsCharacters"\\;\n\nconst StarWarsCharactersContainer\\: React\\.FC \\= \\(\\) \\=\\> \\{\n  const \\[characters\\, isLoading\\, error\\] \\= useFetchStarWarsCharacters\\(\\)\\;\n\n  return \\(\n    \\<CharacterList loading\\=\\{loading\\} error\\=\\{error\\} characters\\=\\{characters\\} \\/\\>\n  \\)\\;\n\\}\\;\n\nexport default StarWarsCharactersContainer\\;\n` }</SyntaxHighlighter>\n<h1>使用 Reducers 进行状态管理</h1>\n<p>大多数情况下，处理组件中的许多状态会导致许多未分组状态的问题，这可能很麻烦且难以处理。在这种情况下，Reducers 模式可能是一个有用的选择。我们可以使用 reducer 将状态分类为某些操作，这些操作在执行时可以更改分组状态。\n此模式允许使用它的开发人员控制组件和/或钩子的状态管理，让他们在发送事件时管理状态更改。\n使用 Reducer 模式的示例如下所示：</p>\n<SyntaxHighlighter language="tsx" style={oneLight} showLineNumbers>{ `import \\{React\\, i useReducer \\} from \'react\'\\;\nconst initstate \\= \\{\n    loggedIn\\: false\\,user\\: null\\,\n    token\\: nuli\n\\}\nfunction authReducer\\(state\\,action\\) \\{\n    switch \\(action\\.type\\) \\{\n        case \'login\'\\:\n            return \\{\n                loggedIn\\: true\\,\n                user\\: action\\. payload\\.user\\,token\\: action\\. payload\\.token\n                \\}\n        case \'logout\'\\:\n            return initState\\;\n        default\\:\n            break\\;\n    \\}\n\\}\nconst AuthComponent \\=\\(\\)\\=\\> \\{\n    const \\[state\\, dispatch\\] \\= useReducer\\(authReducer\\， initstate\\)\\;\n    const logIn \\=\\(\\)\\=\\>\\{\n        dispatch\\(\\{type\\:\'login\'\\,payload\\:\\{\n            user\\:\\{name\\:\'John Doe\'\\}\\,\n            token\\:\'token\'\n        \\}\\}\\)\\;\n    \\}\n    const logout \\= \\(\\)\\=\\> \\{\n        dispatch\\(\\{ type\\: \'logout\' \\}\\)\\;\n    \\}\nreturn \\(\n    \\<div\\>\n    \\{ state\\.loggedIn \\? \\(\n        \\<div\\>\n            \\<p\\> Welcome \\{ state\\.user\\.name \\}\\<\\/ p\\>\\<button onclick\\=\\{logout\\}\\>\\<\\/ button\\>\n        \\<\\/div\\>\n    \\)\\:\\(\n    \\<form onSubmit\\=\\{logIn\\}\\>\n        \\<input type\\="text"\\/\\>\n        \\<input type\\="password"\\/\\>\n        \\<button type\\="submit"\\>\\<\\/button\\>\n    \\<\\/form\\>\n    \\)\n    \\}\n    \\<\\/div\\>\n\\)\n\\}\n` }</SyntaxHighlighter>\n<p>在上面的代码中，该组件调度了两个操作：</p>\n<ul>\n<li>“login”操作类型会触发状态更改，该更改会影响三个状态值，即 loggedIn、user、token。</li>\n<li>“注销”操作只是将状态重置为其初始值。</li>\n</ul>\n<h1>使用提供程序进行数据管理</h1>\n<p>提供程序模式对于数据管理非常有用，因为它利用上下文 API 通过应用程序的组件树传递数据。这种模式是 Props drilling 的有效解决方案，Props drilling 一直是 React 开发中常见的问题。\n为了实现提供程序模式，我们将首先创建一个提供程序组件。提供程序是 Context 对象提供给我们的高阶组件。我们可以利用 React 提供的 createContext 方法构造一个 Context 对象。</p>\n<SyntaxHighlighter language="tsx" style={oneLight} showLineNumbers>{ `export const ThemeContext \\= React\\.createContext\\(null\\)\\;\n\nexport function ThemeProvider\\(\\{ children \\}\\) \\{\n  const \\[theme\\, setTheme\\] \\= React\\.useState\\("light"\\)\\;\n\n  return \\(\n    \\<ThemeContext\\.Provider value\\=\\{\\{ theme\\, setTheme \\}\\}\\>\n      \\{children\\}\n    \\<\\/ThemeContext\\.Provider\\>\n  \\)\\;\n\\}\n` }</SyntaxHighlighter>\n<p>创建提供程序后，我们将使用创建的提供程序组件将依赖于上下文 API 中数据的组件封闭起来。\n为了从上下文 API 获取数据，我们调用 useContext 钩子，它接受上下文作为参数（在本例中为 ThemeContext）。</p>\n<SyntaxHighlighter language="tsx" style={oneLight} showLineNumbers>{ `import \\{ useContext \\} from "react"\\;\nimport \\{ ThemeProvider\\, ThemeContext \\} from "\\.\\.\\/context"\\;\n\nconst HeaderSection \\= \\(\\) \\=\\> \\{\n  \\<ThemeProvider\\>\n    \\<TopNav \\/\\>\n  \\<\\/ThemeProvider\\>\\;\n\\}\\;\n\nconst TopNav \\= \\(\\) \\=\\> \\{\n  const \\{ theme\\, setTheme \\} \\= useContext\\(ThemeContext\\)\\;\n\n  return \\(\n    \\<div style\\=\\{\\{ backgroundColor\\: theme \\=\\=\\= "light" \\? "\\#fff" \\: "\\#000 " \\}\\}\\>\n      \\.\\.\\.\n    \\<\\/div\\>\n  \\)\\;\n\\}\\;\n` }</SyntaxHighlighter>\n<h1>使用 HOC（高阶组件）增强组件</h1>\n<p>高阶组件将组件作为参数，并返回注入了附加数据或功能的增压组件。React 中 HOC 的可能性是由于 React 对组合的偏好而不是继承。\n高阶组件 （HOC） 模式提供了一种增加或修改组件功能的机制，从而促进了组件重用和代码共享。\nHOC 模式的示例如下所示：</p>\n<SyntaxHighlighter language="tsx" style={oneLight} showLineNumbers>{ `import React from \'react\'\n\nconst higherOrderComponent \\= Component \\=\\> \\{\n  return class HOC extends React\\.Component \\{\n    state \\= \\{\n      name\\: \'John Doe\'\n    \\}\n\n    render\\(\\) \\{\n      return \\<Component name\\=\\{this\\.state\\.name \\{\\.\\.\\.this\\.props\\}\\} \\/\\>\n    \\}\n \\}\\}\n\n\nconst AvatarComponent \\= \\(props\\) \\=\\> \\{\n  return \\(\n    \\<div className\\="flex items\\-center justify\\-between"\\>\n      \\<div className\\="rounded\\-full bg\\-red p\\-4"\\>\n          \\{props\\.name\\}\n      \\<\\/div\\>\n      \\<div\\>\n          \\<p\\>I am a \\{props\\.description\\}\\.\\<\\/p\\>\n      \\<\\/div\\>\n    \\<\\/div\\>\n  \\)\n\\}\n\n\nconst SampleHOC \\= higherOrderComponent\\(AvatarComponent\\)\\;\n\n\nconst App \\= \\(\\) \\=\\> \\{\n  return \\(\n    \\<div\\>\n      \\<SampleHOC description\\="Frontend Engineer" \\/\\>\n    \\<\\/div\\>\n  \\)\n\\}\n\nexport default App\\;\n` }</SyntaxHighlighter>\n<p>在上面的代码中，由 higherOrderComponent 提供 props，它将在内部使用。</p>\n<h1>复合组件</h1>\n<p>复合组件模式是一种 React 设计模式，用于管理由子组件组成的父组件。\n这种模式背后的原理是将父组件分解为更小的组件，然后使用道具、上下文或其他 React 数据管理技术来管理这些较小组件之间的交互。\n当需要创建由较小组件组成的可重用的多功能组件时，此模式会派上用场。它使开发人员能够创建复杂的 UI 组件，这些组件可以轻松自定义和扩展，同时保持清晰简单的代码结构。\n复合组件模式的用例示例如下所示：</p>\n<SyntaxHighlighter language="tsx" style={oneLight} showLineNumbers>{ `import React\\, \\{ createContext\\, useState \\} from "react"\\;\n\nconst ToggleContext \\= createContext\\(\\)\\;\n\nfunction Toggle\\(\\{ children \\}\\) \\{\n  const \\[on\\, setOn\\] \\= useState\\(false\\)\\;\n  const toggle \\= \\(\\) \\=\\> setOn\\(\\!on\\)\\;\n\n  return \\(\n    \\<ToggleContext\\.Provider value\\=\\{\\{ on\\, toggle \\}\\}\\>\n      \\{children\\}\n    \\<\\/ToggleContext\\.Provider\\>\n  \\)\\;\n\\}\n\nToggle\\.On \\= function ToggleOn\\(\\{ children \\}\\) \\{\n  const \\{ on \\} \\= useContext\\(ToggleContext\\)\\;\n  return on \\? children \\: null\\;\n\\}\\;\n\nToggle\\.Off \\= function ToggleOff\\(\\{ children \\}\\) \\{\n  const \\{ on \\} \\= useContext\\(ToggleContext\\)\\;\n  return on \\? null \\: children\\;\n\\}\\;\n\nToggle\\.Button \\= function ToggleButton\\(props\\) \\{\n  const \\{ on\\, toggle \\} \\= useContext\\(ToggleContext\\)\\;\n  return \\<button onClick\\=\\{toggle\\} \\{\\.\\.\\.props\\} \\/\\>\\;\n\\}\\;\n\nfunction App\\(\\) \\{\n  return \\(\n    \\<Toggle\\>\n      \\<Toggle\\.On\\>The button is on\\<\\/Toggle\\.On\\>\n      \\<Toggle\\.Off\\>The button is off\\<\\/Toggle\\.Off\\>\n      \\<Toggle\\.Button\\>Toggle\\<\\/Toggle\\.Button\\>\n    \\<\\/Toggle\\>\n  \\)\\;\n\\}\n` }</SyntaxHighlighter>\n<h1>Prop 组合</h1>\n<p>这需要从几个相关的 prop 中创建一个对象，并将其作为单个 prop 传递给组件。\n这种模式允许我们清理代码并简化道具的管理，这在我们想要将大量相关属性传递给组件时特别有用。</p>\n<SyntaxHighlighter language="tsx" style={oneLight} showLineNumbers>{ `import React from "react"\\;\n\nfunction P\\(props\\) \\{\n  const \\{ color\\, size\\, children\\, \\.\\.\\.rest \\} \\= props\\;\n  return \\(\n    \\<p style\\=\\{\\{ color\\, fontSize\\: size \\}\\} \\{\\.\\.\\.rest\\}\\>\n      \\{children\\}\n    \\<\\/p\\>\n  \\)\\;\n\\}\n\nfunction App\\(\\) \\{\n  const paragraphProps \\= \\{\n    color\\: "red"\\,\n    size\\: "20px"\\,\n    lineHeight\\: "22px"\\,\n  \\}\\;\n  return \\<P \\{\\.\\.\\.paragraphProps\\}\\>This is a P\\<\\/P\\>\\;\n\\}\n` }</SyntaxHighlighter>\n<h1>受控输入</h1>\n<p>受控输入模式可用于处理输入字段。此模式涉及使用事件处理程序在输入字段的值发生更改时更新组件状态，以及将输入字段的当前值存储在组件状态中。\n由于 React 控制组件的状态和行为，因此这种模式使代码比不受控制的输入模式更具可预测性和可读性，后者不使用组件的状态，而是直接通过 DOM（文档对象模型）来控制它。\n受控输入模式的用例示例如下所示：</p>\n<SyntaxHighlighter language="tsx" style={oneLight} showLineNumbers>{ `import React\\, \\{ useState \\} from "react"\\;\n\nfunction ControlledInput\\(\\) \\{\n  const \\[inputValue\\, setInputValue\\] \\= useState\\(""\\)\\;\n\n  const handleChange \\= \\(event\\) \\=\\> \\{\n    setInputValue\\(event\\.target\\.value\\)\\;\n  \\}\\;\n\n  return \\<input type\\="text" value\\=\\{inputValue\\} onChange\\=\\{handleChange\\} \\/\\>\\;\n\\}\n` }</SyntaxHighlighter>\n<h1>使用 fowardRefs 管理自定义组件</h1>\n<p>称为 ForwardRef 的高阶组件将另一个组件作为输入，并输出一个传递原始组件的 ref 的新组件。通过这样做，子组件的 ref（可用于检索底层 DOM 节点或组件实例）可供父组件访问。\n创建与第三方库或应用程序中的其他自定义组件交互的自定义组件时，在工作流中包含 ForwardRef 模式非常有帮助。通过授予对库的 DOM 节点或其他组件的 DOM 实例的访问权限，它有助于将此类组件的控制权转移给您。\n下面显示了 forwardRef 模式的用例示例：</p>\n<SyntaxHighlighter language="tsx" style={oneLight} showLineNumbers>{ `import React from "react"\\;\n\nconst CustomInput \\= React\\.forwardRef\\(\\(props\\, ref\\) \\=\\> \\(\n  \\<input type\\="text" \\{\\.\\.\\.props\\} ref\\=\\{ref\\} \\/\\>\n\\)\\)\\;\n\nconst ParentComponent \\= \\(\\) \\=\\> \\{\n  const inputRef \\= useRef\\(null\\)\\;\n\n  useEffect\\(\\(\\) \\=\\> \\{\n    inputRef\\.current\\.focus\\(\\)\\;\n  \\}\\, \\[\\]\\)\\;\n\n  return \\<CustomInput ref\\=\\{inputRef\\} \\/\\>\\;\n\\}\\;\n` }</SyntaxHighlighter>\n<p>在上面的代码中，我们 <code>&lt;CustomInput/&gt;</code> <code>&lt;ParentComponent/&gt;</code> 使用 forwardRefs .</p>\n<h1>总结</h1>\n<p>我们在本文中讨论了 React 设计模式，包括高阶组件、容器表示组件模式、复合组件、受控组件等等。通过将这些设计模式和最佳实践整合到您的 React 项目中，您可以提高代码质量、促进团队协作，并使您的应用程序更具可扩展性、灵活性和可维护性。</p>\n',
    id: "3",
  },
  {
    title: "DataHub",
    date: "2023-12-01",
    categories: "Project",
    excerpt: "红岩网校数据中台",
    html: '<h1>数据中台</h1>\n<p>这个项目是用于展示一些产品以及运营的数据，也便于记录运营数据</p>\n<h2>技术栈</h2>\n<ul>\n<li>Vite + React + TS + Arco-design</li>\n<li>Tailwind</li>\n<li>SWR</li>\n<li>recharts</li>\n<li>husky,commitelint,eslint 等等规范配置</li>\n</ul>\n<h2>项目结构</h2>\n<p>总的来说分为可视化图表页以及后台数据页</p>\n<SyntaxHighlighter language="shell" style={oneLight} showLineNumbers>{ `\\├\\─dtable\n\\│  \\├\\─operations\n\\│  \\└\\─product\n\\│      \\├\\─tracking\n\\│      \\└\\─untracking\n\\├\\─dvisualization\n\\└\\─login\n` }</SyntaxHighlighter>\n<p>我负责的就是 dvisualization 部分</p>\n<h2>项目难点以及亮点</h2>\n<h3>侧边栏</h3>\n<p>后台总体框架的搭建和交通局的类似，但是我这次采用了重邮帮后台的路由以及侧边栏渲染，这里就不多谈了，有兴趣可以看<a href="https://www.yygod0120.com/2023/10/24/%E2%88%A0%E7%97%9B%E5%B1%80/">交通局</a></p>\n<h3>数据可视化界面</h3>\n<p>数据可视化界面中的图表，我采用的是<a href="https://recharts.org/en-US/">Rechart</a>,易上手，类型丰富，最重要的是有中文翻译</p>\n<p>因为涉及到数据的展示，所以我采用数据与组件分离的设计模式，将组件和数据抽离开</p>\n<ul>\n<li>service 中获取数据</li>\n<li>Chart 组件中展示数据</li>\n</ul>\n<h4>service</h4>\n<p>先说 service，我们技术选型的时候选择了 SWR 作为网络请求库,原因有以下几点：</p>\n<ol>\n<li>SWR 具有自动重新请求以及用户重新聚集时请求，这有助于数据实时更新以及展示</li>\n<li>SWR 能避免很多 useEffect 中编写网络请求遇到的问题，比如说请求顺序和返回顺序的不一致以及依赖相关的问题。</li>\n<li>完美符合了数据组件分离政策</li>\n<li>相比于 React Query，SWR 更容易上手</li>\n</ol>\n<p>但是 SWR 同样也具有一些缺点</p>\n<SyntaxHighlighter language="typescript" style={oneLight} showLineNumbers>{ `export function useGetPv\\(\\) \\{\n  const \\{ data\\, error\\, isLoading \\} \\= useSWR\\(\n    \\`\\/data\\-middle\\-office\\/pvuv\\?type\\=pv\\&periods\\=\\$\\{xAxis\\["days"\\]\\}\\`\\,\n    fetcher\n  \\)\\;\n  if \\(\\!isLoading \\&\\& \\!error\\) \\{\n    const cqappPv \\= data\\.products\\.cqapp\\;\n    const cqhelperPv \\= data\\.products\\.cqhelper\\;\n    return \\[cqappPv\\, cqhelperPv\\]\\;\n  \\}\n  \\/\\/   return \\[null\\, null\\]\\;\n\\}\n` }</SyntaxHighlighter>\n<p>像这样一个 swr 获取 PV 数据，在 isLoading 阶段是不会有返回值的，这样就会导致<code>const [cqappPv, cqhelperPv] = useGetPv()</code>报错 undefined\n所以我采用<code>return [null,null]</code>来处理,像这样的空值处理在数据组件分离中很常见，感觉我这样的写法也不算是最优的。</p>\n<p>另外一点关于 service 数据处理的是关于类型的处理\n早在<a href="https://www.yygod0120.com/2023/09/18/TheFirstRedrockProject/">暑假的场地申请</a>中遇到两个模块类似的数据的处理，当时我的做法是直接拆开为两个部分，但是这样会有一些问题：</p>\n<ul>\n<li>类型重复度高，无用代码数量多，维护起来困难</li>\n</ul>\n<SyntaxHighlighter language="ts" style={oneLight} showLineNumbers>{ `\\/\\/\\，\\其\\余\\场\\地\nexport interface DataType \\{\n  application_id\\: number\\;\n  location_id\\: number\\;\n  place\\?\\: string\\;\n  apply_date\\: number\\;\n  periods\\?\\: boolean\\[\\]\\;\n  use_date\\?\\: string\\;\n  application\\: string\\;\n  applicant_id\\: string\\;\n  organization\\?\\: string\\;\n  is_org\\: boolean\\;\n  state\\: number\\;\n  reason\\: string\\;\n  phone\\: string\\;\n\\}\n\\/\\/\\科\\技\\会\\堂\nexport interface techologyHallDataType \\{\n  application_id\\: number\\;\n  location_id\\: number\\;\n  place\\?\\: string\\;\n  apply_date\\: number\\;\n  payloads\\: payload\\[\\]\\;\n  periods\\?\\: boolean\\[\\]\\;\n  use_date\\?\\: string\\;\n\n  application\\: string\\;\n  applicant_id\\: string\\;\n  organization_name\\?\\: string\\;\n  is_org\\: boolean\\;\n  state\\: number\\;\n  reason\\: string\\;\n  phone\\: string\\;\n\\}\n` }</SyntaxHighlighter>\n<ul>\n<li>对应模块代码重复度高,cv 过多</li>\n</ul>\n<p>而这次的运营数据也遇到了对应的问题，但这次我选择不分开而是联合起来\n数据类型部分：</p>\n<SyntaxHighlighter language="ts" style={oneLight} showLineNumbers>{ `export type OperationData \\= \\{\n  id\\: string\\;\n  name\\: string\\;\n  periods\\: string\\;\n  purpose\\: string\\;\n  users\\: string\\;\n  price\\: string\\;\n\\}\\;\n\nexport type helperOperationData \\= OperationData \\& \\{\n  reading\\: number\\;\n  transmit\\: number\\;\n\\}\\;\n\nexport type qqOperationData \\= OperationData \\& \\{\n  reading\\: number\\;\n  comment\\: number\\;\n\\}\\;\n\nexport type otherData \\= OperationData \\& \\{\n  way\\: string\\;\n  result\\: string\\;\n\\}\\;\n` }</SyntaxHighlighter>\n<p>获取数据部分：</p>\n<SyntaxHighlighter language="ts" style={oneLight} showLineNumbers>{ `export type Operations\\<T extends "qq" \\| "helper" \\| "other"\\> \\= T extends "qq"\n  \\? qqOperationData\\[\\]\n  \\: T extends "helper"\n  \\? helperOperationData\\[\\]\n  \\: T extends "other"\n  \\? otherData\\[\\]\n  \\: never\\;\nexport function getOperationData\\<T extends "qq" \\| "helper" \\| "other"\\>\\(\n  project\\: T\\,\n  periods\\?\\: string\n\\)\\: Operations\\<T\\> \\| undefined \\{\n  const url \\= periods\n    \\? \\`\\/data\\-middle\\-office\\/runtimes\\/\\$\\{project\\}\\?periods\\=\\$\\{periods\\}\\`\n    \\: \\`\\/data\\-middle\\-office\\/runtimes\\/\\$\\{project\\}\\`\\;\n  \\/\\/ eslint\\-disable\\-next\\-line react\\-hooks\\/rules\\-of\\-hooks\n  const \\{ data\\, error\\, isLoading \\} \\= useSWR\\(url\\, fetcher\\)\\;\n  if \\(isLoading\\) \\{\n    console\\.log\\("Loading\\.\\.\\."\\)\\;\n    return undefined\\;\n  \\} else if \\(error\\) \\{\n    console\\.log\\("Error\\:"\\, error\\)\\;\n    return undefined\\;\n  \\} else \\{\n    console\\.log\\("Data\\:"\\, data\\)\\;\n    return data as Operations\\<T\\>\\;\n  \\}\n\\}\n` }</SyntaxHighlighter>\n<p>采取对应参数返回对应数据模式，一开始采用的是函数重载方式，但是过于臃肿，于是换成这种泛型模式</p>\n<h4>Charts</h4>\n<p>图表部分我采用的是二层封装的思路</p>\n<ul>\n<li>第一层：对 Rechart 中的折线图，饼图以及柱状图进行封装，让图本身符合要求</li>\n<li>第二层：对封装后的 Rechart 再进行 Header 以及 Bottom 的封装，让图&quot;更完整&quot;</li>\n</ul>\n<p>为了文章的大小就不在这展示了。</p>\n<h2>总结</h2>\n<p>这算是第 4 次做项目，可能也是因为项目本身也不大，做起来还是很快的，只是在后端接口上耽误了时间</p>\n<p>debug 能力也有所提高，对于一些小 bug 比如跨域以及图片路径丢失等等，解决起来比暑假快上不少</p>\n<p>重点收获是图表的封装以及对网络请求的一些理解，还有 React Design 的一些想法</p>\n<blockquote>\n<p>记得关注 RRFE-CLI</p>\n</blockquote>\n',
    id: "1",
  },
  {
    title: "RSC",
    date: "2023-12-04",
    categories: "Techology",
    excerpt: "What is RSC, and how it works",
    html: '<p>推荐阅读：</p>\n<p><a href="https://chentsulin.medium.com/react-%E6%96%B0%E6%A6%82%E5%BF%B5-server-components-d632f9a18463">React 新概念-服务器组件</a></p>\n<p><a href="https://www.plasmic.app/blog/how-react-server-components-work">How React server components work: an in-depth guide</a></p>\n<p><a href="https://legacy.reactjs.org/blog/2020/12/21/data-fetching-with-react-server-components.html">引入零捆绑大小的 React 服务器组件</a></p>\n<h1>前言</h1>\n<p>在笔者刚了解到 RSC(React Service Component)的时候，笔者总是把他和 SSR(Service-Side Render)混为一谈，其实他们完全就是两个概念。</p>\n<p>SSR 代表的是一种渲染方式，与之对应的是 CSR(Client-Side Render),SSR 是一种利于 SEC，加快首屏渲染减少白屏时间的解决方案，被称之为服务端渲染。\n我在这篇文章中并不会提到相关内容，如果感兴趣可以去阅读<a href="https://github.com/yacan8/blog/issues/30">彻底理解服务端渲染-SSR</a></p>\n<p>本篇文章的重点，是 RSC</p>\n<h1>什么是 RSC</h1>\n<p>早在 2020 年年末，React 官方放出了一个演讲和一段演示，主要内容就是关于 RSC，一种零捆绑大小的 React 服务端组件，致力于解决现阶段的两个问题：</p>\n<ul>\n<li>应用程序中日益增加的捆绑包大小</li>\n<li>缓慢的网络请求</li>\n</ul>\n<h1>服务端组件和客户端组件的区别</h1>\n<p>你可以通过<code>use service</code>或者<code>use client</code>来告诉 React 你想用服务端组件还是客户端组件</p>\n<SyntaxHighlighter language="jsx" style={oneLight} showLineNumbers>{ `"use client"\\;\n\nimport \\{ useRef\\, useEffect \\} from "react"\\;\n\nexport default function Circle\\(\\) \\{\n  const ref \\= useRef\\(null\\)\\;\n  useLayoutEffect\\(\\(\\) \\=\\> \\{\n    const canvas \\= ref\\.current\\;\n    const context \\= canvas\\.getContext\\("2d"\\)\\;\n    context\\.reset\\(\\)\\;\n    context\\.beginPath\\(\\)\\;\n    context\\.arc\\(100\\, 75\\, 50\\, 0\\, 2 \\* Math\\.PI\\)\\;\n    context\\.stroke\\(\\)\\;\n  \\}\\)\\;\n  return \\<canvas ref\\=\\{ref\\} \\/\\>\\;\n\\}\n` }</SyntaxHighlighter>\n<SyntaxHighlighter language="jsx" style={oneLight} showLineNumbers>{ `"use server"\\;\n\nexport default async function requestUsername\\(formData\\) \\{\n  const username \\= formData\\.get\\("username"\\)\\;\n  if \\(canRequest\\(username\\)\\) \\{\n    \\/\\/ \\.\\.\\.\n    return "successful"\\;\n  \\}\n  return "failed"\\;\n\\}\n` }</SyntaxHighlighter>\n<p>当然在一个应用程序中你可以混用两种组件,就像这样：</p>\n<Image src={reactservercomponents} alt="react-server-components" \n      sizes="100vw"\n      style={{\n        width: \'100%\',\n        height: \'auto\',\n      }} />\n\n<p>但值得注意的是，你只能在服务器组件中调用服务器组件或者客户端组件，而客户端组件只能调用客户端组件不能调用服务器组件:</p>\n<SyntaxHighlighter language="jsx" style={oneLight} showLineNumbers>{ `\\/\\/ \\不\\可\n"use client"\\;\nimport ServerComponent from "\\.\\/ServerComponent\\.js"\\;\nexport default function ClientComponent\\(\\) \\{\n  return \\(\n    \\<div\\>\n      \\<ServerComponent \\/\\>\n    \\<\\/div\\>\n  \\)\\;\n\\}\n` }</SyntaxHighlighter>\n<p>等等，不是说客户端组件不能调用服务器端组件吗?那是怎么做到上面那张图中的树结构中把服务器端组件(orange)挂在客户端组件(blue)上的？</p>\n<p>虽然说我们不能直接 import 服务器组件在客户端组件中，但是我们可以 props 传入的方法将暂时不知道是什么的 ReactNode 作为 props 传给到客户端组件中，而这些 ReactNode 也许就是服务器端组件：</p>\n<SyntaxHighlighter language="jsx" style={oneLight} showLineNumbers>{ `\\/\\/ ClientComponent\\.jsx\n\'use client\'\nexport default function ClientComponent\\(\\{ children \\}\\) \\{\n  return \\(\n    \\<div\\>\n      \\<h1\\>Hello from client land\\<\\/h1\\>\n      \\{children\\}\n    \\<\\/div\\>\n  \\)\\;\n\\}\n\n\\/\\/ ServerComponent\\.jsx\n\'use server\'\nexport default function ServerComponent\\(\\) \\{\n  return \\(\n      \\<span\\>Hello from server land\\<\\/span\\>\n  \\)\\;\n\\}\n\n\\/\\/ OuterServerComponent\\.jsx\n\\/\\/ OuterServerComponent \\可\\以\\支\\援\\客\\戶\\端\\和\\伺\\服\\器\\元\\件\\實\\例\\化\n\\/\\/ \\我\\們\\把 \\<ServerComponent \\/\\> \\作\\為 children \\傳\\入\n\'use service\'\nimport ClientComponent from \'\\.\\/ClientComponent\'\\;\nimport ServerComponent from \'\\.\\/ServerComponent\'\\;\nexport default function OuterServerComponent\\(\\) \\{\n  return \\(\n    \\<ClientComponent\\>\n        \\<ServerComponent \\/\\>\n    \\<\\/ClientComponent\\>\n  \\)\\;\n\\}\n` }</SyntaxHighlighter>\n<p>这样就实现了在外部的 service 组件中传入了一个客户端组件，而这个客户端组件下挂载了一个服务端组件，实现了上图的树形结构</p>\n<h1>RSC 是如何渲染的</h1>\n<p>简单的来说：当 React 想要渲染某个服务器组件的时候，会发送一个请求给服务器，携带着各种信息来确定所要渲染的组件及其属性，然后服务器会将这些组件序列化成 JSON 格式再返回给客户端，在客户端上再反序列化，最终呈现出来。</p>\n<p>接下来我们近一步了解一下 RSC 渲染的生命周期</p>\n<h2>RSC 渲染的生命周期</h2>\n<p>注意：以下内容来源于<a href="https://www.plasmic.app/blog/how-react-server-components-work">这篇文章</a>\n我对其进行了一点自己的翻译，但感觉依旧晦涩难懂，如果不感兴趣可以直接跳过</p>\n<h3>1. 服务器收到渲染请求</h3>\n<p>在上面我们提到过客户端组件是没法引入服务端组件的，所以我们的 RSC 页面将始终以服务器端组件开头。根组件始终是服务器端组件。\n当我们开始准备渲染时，我们将会发送特定的请求到特定的 url 上，服务器通过我们发送的请求，根据信息来确定要使用的服务器组件。</p>\n<h3>2. 服务器将根组件元素序列化为 JSON</h3>\n<p>这里的最终目标是将初始根服务器组件呈现为基本 html 标记和客户端组件“占位符”的树。然后，我们可以 JSON 化这棵树，将其发送到浏览器，浏览器可以对其进行反 JSON，用真实的客户端组件填充客户端占位符，并呈现最终结果。</p>\n<p>还记得上面写到的一个<code>&lt;OuterServerComponent/&gt;</code>组件吗，如果我们要渲染这个服务端组件，是将其直接<code>JSON.stringfy()</code>吗？</p>\n<p>差不多，但不完全是！回想一下其实 React 元素就是一个对象，字段 type 可以是字符串，要么是基本 html 标签，比如 <code>div</code> - 或者是一个函数——对于 React 组件实例。</p>\n<SyntaxHighlighter language="js" style={oneLight} showLineNumbers>{ `\\/\\/ React element for \\<div\\>oh my\\<\\/div\\>\n\\> React\\.createElement\\("div"\\, \\{ title\\: "oh my" \\}\\)\n\\{\n  \\$\\$typeof\\: Symbol\\(react\\.element\\)\\,\n  type\\: "div"\\,\n  props\\: \\{ title\\: "oh my" \\}\\,\n  \\.\\.\\.\n\\}\n\n\\/\\/ React element for \\<MyComponent\\>oh my\\<\\/MyComponent\\>\n\\> function MyComponent\\(\\{children\\}\\) \\{\n    return \\<div\\>\\{children\\}\\<\\/div\\>\\;\n  \\}\n\\> React\\.createElement\\(MyComponent\\, \\{ children\\: "oh my" \\}\\)\\;\n\\{\n  \\$\\$typeof\\: Symbol\\(react\\.element\\)\\,\n  type\\: MyComponent  \\/\\/ reference to the MyComponent function\n  props\\: \\{ children\\: "oh my" \\}\\,\n  \\.\\.\\.\n\\}\n` }</SyntaxHighlighter>\n<p>但是一个函数是没法被 JSON 序列化的，所以 React 提供了一个特殊的替换函数去被 JSON 序列化。\n你可以在<a href="https://github.com/facebook/react/blob/42c30e8b122841d7fe72e28e36848a6de1363b0c/packages/react-server/src/ReactFlightServer.js#L368">ReactFlightServer.js</a>中找一个 <code>resolveModelToJSON()</code> 函数，就是特殊的替换函数。</p>\n<p>所以，当我们序列化根组件的时候，就会遇到三种不同的 React 元素</p>\n<ul>\n<li>如果是个普通的 HTML 标签元素(就像<code>&lt;div&gt;</code>)，那么没事，它已经是 <code>div</code> 可序列化的了！没什么特别可做的。</li>\n<li>如果是一个服务器组件元素，则和渲染根组件一样通过请求传递信息给服务器，调用对应的服务器组件并且接着进行序列化</li>\n<li>如果是一个客户端组件元素，实际上它也已经可以序列化了，他的 type 指向的就是<strong>模块引用对象</strong>而非组件函数。</li>\n</ul>\n<h4>什么是模块引用对象</h4>\n<p>RSC 为 React 元素 type 的字段引入了一个新的可能值，称为“模块引用”;它不是组件函数，而是对它的可序列化“引用”。\n例如，元素 <code>ClientComponent</code> 可能如下所示：</p>\n<SyntaxHighlighter language="JS" style={oneLight} showLineNumbers>{ `\\{\n  \\$\\$typeof\\: Symbol\\(react\\.element\\)\\,\n  \\/\\/ The type field  now has a reference object\\,\n  \\/\\/ instead of the actual component function\n  type\\: \\{\n    \\$\\$typeof\\: Symbol\\(react\\.module\\.reference\\)\\,\n    \\/\\/ ClientComponent is the default export\\.\\.\\.\n    name\\: "default"\\,\n    \\/\\/ from this file\\!\n    filename\\: "\\.\\/src\\/ClientComponent\\.client\\.js"\n  \\}\\,\n  props\\: \\{ children\\: "oh my" \\}\\,\n\\}\n` }</SyntaxHighlighter>\n<p>我们将对客户端组件函数的引用转换为可序列化的“模块引用”对象要借助于外界。\nReact 团队已经发布了对 webpack 的官方 RSC 支持， react-server-dom-webpack 作为 webpack 加载器或节点寄存器。\n当服务器组件从 <code>\\*.client.jsx</code> 文件中导入某些内容时，它不是实际获取该内容，而是仅获取一个模块引用对象，其中包含该内容的文件名和导出名称。在服务器上构建的 React 树中，从来没有任何客户端组件函数！\n再次考虑上面的例子，我们试图序列化 <code>&lt;OuterServerComponent  /&gt;</code> ;我们最终会得到一个 JSON 树，如下所示：</p>\n<SyntaxHighlighter language="js" style={oneLight} showLineNumbers>{ `\\{\n  \\/\\/ The ClientComponent element placeholder with "module reference"\n  \\$\\$typeof\\: Symbol\\(react\\.element\\)\\,\n  type\\: \\{\n    \\$\\$typeof\\: Symbol\\(react\\.module\\.reference\\)\\,\n    name\\: "default"\\,\n    filename\\: "\\.\\/src\\/ClientComponent\\.client\\.js"\n  \\}\\,\n  props\\: \\{\n    \\/\\/ children passed to ClientComponent\\, which was \\<ServerComponent \\/\\>\\.\n    children\\: \\{\n      \\/\\/ ServerComponent gets directly rendered into html tags\\;\n      \\/\\/ notice that there\'s no reference at all to the\n      \\/\\/ ServerComponent \\- we\'re directly rendering the \\`span\\`\\.\n      \\$\\$typeof\\: Symbol\\(react\\.element\\)\\,\n      type\\: "span"\\,\n      props\\: \\{\n        children\\: "Hello from server land"\n      \\}\n    \\}\n  \\}\n\\}\n` }</SyntaxHighlighter>\n<p>离开模块引用对象，回到序列化根组件,在这个过程的最后，我们得到这样一个 React 树：\n<Image src={reactservercomponentsplaceholders} alt="react-server-components-placeholders" \n      sizes="100vw"\n      style={{\n        width: \'100%\',\n        height: \'auto\',\n      }} />\n它将被发送到浏览器上以完成最后一步</p>\n<p>还有一点需要记住，因为我们要序列化整个 React 树，所以我们传递的 props 也得是能被序列化的，这意味着从服务器组件中，您不能将事件处理程序作为 prop 传递下来！</p>\n<SyntaxHighlighter language="js" style={oneLight} showLineNumbers>{ `\\/\\/ NOT OK\\: server components cannot pass functions as a prop\n\\/\\/ to its descendents\\, because functions are not serializable\\.\nfunction SomeServerComponent\\(\\) \\{\n  return \\<button onClick\\=\\{\\(\\) \\=\\> alert\\("OHHAI"\\)\\}\\>Click me\\!\\<\\/button\\>\\;\n\\}\n` }</SyntaxHighlighter>\n<p>但是，当我们遇到客户端组件时，我们从不调用客户端组件函数，因此，如果您有一个实例化另一个客户端组件的客户端组件：</p>\n<SyntaxHighlighter language="js" style={oneLight} showLineNumbers>{ `function SomeServerComponent\\(\\) \\{\n  return \\<ClientComponent1\\>Hello world\\!\\<\\/ClientComponent1\\>\\;\n\\}\n\nfunction ClientComponent1\\(\\{children\\}\\) \\{\n  \\/\\/ It is okay to pass a function as prop from client to\n  \\/\\/ client components\n  return \\<ClientComponent2 onChange\\=\\{\\.\\.\\.\\}\\>\\{children\\}\\<\\/ClientComponent2\\>\\;\n\\}\n` }</SyntaxHighlighter>\n<p><code>ClientComponent2</code> 根本没有出现在这个 RSC-JSON 树中;相反，我们只会看到一个带有模块引用和 <code>props</code> 的 <code>ClientComponent1</code> 元素。因此，将事件处理程序作为道具传递给 <code>ClientComponent2</code> 是完全合法的</p>\n<h3>3. 浏览器重构 React 树</h3>\n<p>终于到了我们的最后一步：\n浏览器接收来自服务器的 JSON 输出，现在必须开始重建要在浏览器中呈现的 React 树。每当我们遇到一个元素 type 是模块引用时，我们都会希望将其替换为对真实客户端组件函数的引用。\n这个工作依旧需要外界的帮助，他们帮我们将服务器上的模块引用替换了客户端组件函数，现在同样可以用浏览器中真正的客户端组件函数替换这些模块引用。\n重建的 React 树将如下所示——只交换了原生标签和客户端组件：\n<Image src={reactservercomponentsclient} alt="react-server-components-client" \n      sizes="100vw"\n      style={{\n        width: \'100%\',\n        height: \'auto\',\n      }} />\n然后我们像往常一样渲染并将这棵树提交到 DOM 中！</p>\n<h2>关于 Suspense</h2>\n<p>Suspense 是一个 React 组件，是专门用于 RSC 的一个组件\nSuspense 允许你在 React 组件需要一些尚未准备好的东西（获取数据、延迟导入组件等）时抛出 promise 。这些 promise 被捕获在“Suspense 边界”——每当渲染 Suspense 子树抛出 promise 时，React 都会暂停渲染该子树，直到 promise 被解析，然后重试。\n多亏了 Suspense，您可以在服务器组件获取数据时让服务器流式传输 RSC 输出，让浏览器在数据可用时以增量方式呈现数据，并在必要时动态获取客户端组件包。</p>\n<blockquote>\n<p>曾经笔者以为 Suspense 只是和 Loading 组件类似的东西，也是用于数据请求获取中使用，但现在看来似乎不是\n关于 Suspense 的部分，笔者也没了解清楚，想了解更多的可以去看开头推荐的文章</p>\n</blockquote>\n<h2>服务器组件的缺点</h2>\n<ul>\n<li>学习一个新东西总是需要时间，心智负担重</li>\n<li>服务器组件上用不了浏览器相关的 api，甚至没法使用 useState，useEffect 等相关状态的 Hooks</li>\n<li>写 RSC 组件比写单纯的客户端组件复杂不少，需要了解相关的 bundler 以及 framework(NextJs)</li>\n<li>目前来说普及度还不够高，迁移难度高，即使与 RSC 最契合的 NEXTJS，你迁移起来依旧难上加难，更别说原生 React 项目</li>\n</ul>\n',
    id: "4",
  },
  {
    title: "我的2023",
    date: "2024-01-01",
    categories: "Life",
    excerpt: "2023年终总结",
    html: "<blockquote>\n<p>这是我的第一篇年末总结。</p>\n</blockquote>\n<p>2023 年完美谢幕，说不上万事如意，好在结果令人满意。</p>\n<p>在过去的一年里：</p>\n<ul>\n<li>写了二十八篇博客</li>\n<li>去了两个城市</li>\n<li>看过了六部电影，八部电视剧，零本书</li>\n<li>完成了六个前端项目</li>\n</ul>\n<h1>关于 2023</h1>\n<p>今年的成长相比较与去年，好比从 0 到 1 与从 1 到 10 的区别。\n年初还是一个刚入门甚至都不算入门的 FEer，到年末成为一名入门级 FEer。\n途径无数项目鞭打，有考核的，有学校的甚至还有政府的。</p>\n<Image src={music} alt=\"拙劣的模仿\" \n      sizes=\"100vw\"\n      style={{\n        width: '100%',\n        height: 'auto',\n      }} />\n<Image src={venue} alt=\"后台管理\" \n      sizes=\"100vw\"\n      style={{\n        width: '100%',\n        height: 'auto',\n      }} />\n\n<p>学业方面，没有挂科是基本要求，额外之喜是一份最低等的奖学金。\n<Image src={study} alt=\"学分统计\" \n      sizes=\"100vw\"\n      style={{\n        width: '100%',\n        height: 'auto',\n      }} /></p>\n<p>在过去的一年里还有很多值得纪念的事情，比如武汉和长沙。\n<Image src={wuhan} alt=\"武汉\" \n      sizes=\"100vw\"\n      style={{\n        width: '100%',\n        height: 'auto',\n      }} />\n<Image src={changsha} alt=\"长沙\" \n      sizes=\"100vw\"\n      style={{\n        width: '100%',\n        height: 'auto',\n      }} /></p>\n<p>第一本纪念相册，第一次在外面跨年，第一次一个人生病去大医院看病。</p>\n<p>最后贴上今年的 Github 总结\n<Image src={YYGod0120} alt=\"github年度总结\" \n      sizes=\"100vw\"\n      style={{\n        width: '100%',\n        height: 'auto',\n      }} /></p>\n<h1>关于 2024</h1>\n<p>新的一年，要有新的期望：</p>\n<ul>\n<li>身体健康，万事如意</li>\n<li>从 10 到 100，好好沉淀</li>\n<li>找个大厂实习，接受社会拷打</li>\n<li>更爱爱我的人</li>\n<li>更加投入到我的健身事业中</li>\n<li>读三本书</li>\n<li>别挂科</li>\n</ul>\n",
    id: "7",
  },
  {
    title: "NewBlog",
    date: "2024-02-03",
    categories: "Project",
    excerpt:
      "有一个由自己打造的博客，是每个前端开发必备项目。我通过半个月时间，尝试Next搭建了一个博客。",
    html: "<h1>前言</h1>\n<p>原本，我利用 Hexo 搭建了一个个人博客，刚开始还挺新鲜的，但慢慢就觉得样式单调，而且我想加入评论以及流量监控很麻烦。所以想着要不自己手写一个，更好控制也能自定义样式。于是 yyblog 就孕育而生</p>\n<h1>结构</h1>\n<p>整个博客，不仅仅由 yyblog 组成，还有 ybg-cli 脚手架，用于自动创建删除文章以及编译文章。</p>\n<ul>\n<li><p><strong>yyblog</strong></p>\n<ul>\n<li>Nextjs</li>\n<li>typescript</li>\n<li>tailwind</li>\n<li>react-syntax-highlighter</li>\n</ul>\n</li>\n<li><p><strong>ybg-cli</strong></p>\n<ul>\n<li>cac</li>\n<li>gray-matter</li>\n<li></li>\n</ul>\n</li>\n</ul>\n",
    id: "2",
  },
];
module.exports = {
  data,
};
