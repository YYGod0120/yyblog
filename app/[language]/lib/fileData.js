const DATA = [{"title":"YBG-第七期","date":"2024-03-18","categories":"Weekly","excerpt":"这里是每周总结，记录每一周的趣事，技术分享以及学习生活。","html":"<h2>Technology/Study</h2>\n<ol>\n<li><p>这周在写ai-qa遇到post流式响应的问题，但是目前网上好像只有关于axios的get响应流的解决方案。</p>\n<Image src={axiosWeak} alt=\"github上的closed-issue\" \n      sizes=\"100vw\"\n      style={{\n        width: '100%',\n        height: 'auto',\n      }} />\n\n<p><a href=\"https://stackoverflow.com/questions/71534322/http-stream-using-axios-node-js\">HTTP Stream using Axios (Node JS)</a>\n只好回到使用Fetch舍去好用的拦截器了</p>\n</li>\n<li><p><a href=\"https://zh.javascript.info/\">现代javascript教程</a>:不管是老手还是新手，这本教程都会给你带来不一样的对js的理解，基本全文免费，附带练习，由浅入深。</p>\n</li>\n<li><p><a href=\"https://app.diagrams.net/\">Draw.io</a>: 一个专门画原型图，思维导图等流程图的网站，简单上手</p>\n</li>\n<li><p><a href=\"https://atelier-anchor.com/typefaces/smiley-sans\">德意黑字体</a>: 适合广告等等网站的字体</p>\n<Image src={font} alt=\"github上的closed-issue\" \n      sizes=\"100vw\"\n      style={{\n        width: '100%',\n        height: 'auto',\n      }} /></li>\n</ol>\n<h2>Life</h2>\n<ol>\n<li><p>周刊数目变多，准备再写一个页面专门用来放周刊，想想好的思路</p>\n</li>\n<li><p>这周仔细查阅了一下各种不同网络请求库的区别，稍微写了一篇文章。</p>\n</li>\n<li><p><a href=\"https://typescript-book.vercel.app/zh-cn/?ref=dailydev\">《Concise TypeScript Book》</a>在前面周刊中有提到过，花了几天时间读完了。总结来说内容不多，快慢一周左右就能看完，深度较深，不建议没学过或者打算通过这本书来学ts的人来学习。熟悉以及用过ts的人来看这本书会对ts有更深的理解。</p>\n</li>\n</ol>\n","id":"7"},{"title":"XHRvsFetch","date":"2024-03-17","categories":"Technology","excerpt":"什么是XHR，什么是Fetch，为什么用XHR,为什么用Fetch","html":"<h1>前言</h1>\n<p>这段时间做的ai-qa平台，遇到了一个业务需求，就是类gpt的post流式响应：通过post问题到后端，后端采用流式响应，即一段一段的返回数据，我再进行样式的渲染。\n在此我却遇到了问题，axios没法对post流式响应。</p>\n<Image src={axiosWeak} alt=\"github上的closed-issue\" \n      sizes=\"100vw\"\n      style={{\n        width: '100%',\n        height: 'auto',\n      }} />\n\n<p>相反原生的Fetch却能做到post流式处理。</p>\n<SyntaxHighlighter language=\"js\" style={oneLight} showLineNumbers>{ `\\/\\/\\核\\心\\代\\码\nasync function run\\(\\) \\{\n  aborter\\.abort\\(\\)\\; \\/\\/ cancel previous request\n  outputEl\\.innerText \\= \"\"\\;\n  aborter \\= new AbortController\\(\\)\\;\n  const prompt \\= new FormData\\(formEl\\)\\.get\\(\"prompt\"\\)\\;\n  try \\{\n    const response \\= await fetch\\(\"http\\:\\/\\/192\\.168\\.223\\.26\\:5000\\/chain\"\\, \\{\n      signal\\: aborter\\.signal\\,\n      method\\: \"POST\"\\,\n      headers\\: \\{ \"Content\\-Type\"\\: \"application\\/json\" \\}\\,\n      body\\: JSON\\.stringify\\(\\{\n        prompt\\,\n      \\}\\)\\,\n    \\}\\)\\;\n    const reader \\= response\\.body\\.getReader\\(\\)\\;\n    const decoder \\= new TextDecoder\\(\\)\\;\n    while \\(true\\) \\{\n      const \\{ done\\, value \\} \\= await reader\\.read\\(\\)\\;\n      if \\(done\\) \\{\n        break\\;\n      \\}\n      const decoded \\= decoder\\.decode\\(value\\, \\{ stream\\: true \\}\\)\\;\n      console\\.log\\(decoded\\)\\;\n      outputEl\\.innerText \\+\\= decoded\\;\n    \\}\n  \\} catch \\(err\\) \\{\n    console\\.error\\(err\\)\\;\n  \\}\n\\}\n` }</SyntaxHighlighter>\n<p>于是我去查了查相关资料，发现<code>Axios</code>好像有些地方真不如<code>Fetch</code></p>\n<h1>XHR(XMLHttpRequests)</h1>\n<p><code>Axios</code>是基于<code>Promise</code>的网络请求库，在node端使用nodejs自带的http模块，在浏览器端采用的是XMLHttpRequests。它的功能包括但不仅限于拦截请求和响应，自动转化JSON数据以及取消请求。</p>\n<p>更多内容可以直接查看<a href=\"https://axios-http.com/zh/docs/intro\">官网</a>。</p>\n<p>这里主要是关于什么是<strong>XHR(XMLHttpRequests)</strong>:</p>\n<p>XHR是古早的浏览器内建对象，虽然名字里有XML，它不仅仅能够操作XML格式的数据，其他数据也能够操作，例如图片，文档等等。\n但随着更新的Fetch的出现，XHR渐渐消失，唯一留下的它的理由估计就是为了兼容旧浏览器,适配旧脚本,以及做到跟踪上传进度(Fetch做不到)。</p>\n<h2>XMLHttpRequests基础</h2>\n<p>XMLHttpRequest 有两种执行模式：同步（synchronous）和异步（asynchronous）</p>\n<p>先来看看最常使用的异步：</p>\n<p><strong>1. 创建 <code>XMLHttpRequest</code></strong></p>\n<SyntaxHighlighter language=\"js\" style={oneLight} showLineNumbers>{ `let xhr \\= new XMLHttpRequest\\(\\)\\;\n` }</SyntaxHighlighter>\n<p><strong>2. 初始化它</strong></p>\n<SyntaxHighlighter language=\"js\" style={oneLight} showLineNumbers>{ `xhr\\.open\\(method\\, URL\\, \\[async\\, user\\, password\\]\\)\\;\n` }</SyntaxHighlighter>\n<ul>\n<li>method —— HTTP 方法。通常是 &quot;GET&quot; 或 &quot;POST&quot;。</li>\n<li>URL —— 要请求的 URL，通常是一个字符串，也可以是 URL 对象。</li>\n<li>async —— 如果显式地设置为 false，那么请求将会以同步的方式处理，我们稍后会讲到它。</li>\n<li>user，password —— HTTP 基本身份验证（如果需要的话）的登录名和密码。</li>\n</ul>\n<p><strong>3. 发送请求</strong></p>\n<SyntaxHighlighter language=\"js\" style={oneLight} showLineNumbers>{ `xhr\\.send\\(\\[body\\]\\)\\;\n` }</SyntaxHighlighter>\n<p><strong>4. 监听xhr事件获取响应</strong></p>\n<ul>\n<li>load —— 当请求完成（即使 HTTP 状态为 400 或 500 等），并且响应已完全下载。</li>\n<li>error —— 当无法发出请求，例如网络中断或者无效的 URL。</li>\n<li>progress —— 在下载响应期间定期触发，报告已经下载了多少。</li>\n</ul>\n<SyntaxHighlighter language=\"js\" style={oneLight} showLineNumbers>{ `xhr\\.onload \\= function \\(\\) \\{\n  alert\\(\\`Loaded\\: \\$\\{xhr\\.status\\} \\$\\{xhr\\.response\\}\\`\\)\\;\n\\}\\;\n\nxhr\\.onerror \\= function \\(\\) \\{\n  \\/\\/ \\仅\\在\\根\\本\\无\\法\\发\\出\\请\\求\\时\\触\\发\n  alert\\(\\`Network Error\\`\\)\\;\n\\}\\;\n\nxhr\\.onprogress \\= function \\(event\\) \\{\n  \\/\\/ \\定\\期\\触\\发\n  \\/\\/ event\\.loaded \\—\\— \\已\\经\\下\\载\\了\\多\\少\\字\\节\n  \\/\\/ event\\.lengthComputable \\= true\\，\\当\\服\\务\\器\\发\\送\\了 Content\\-Length header \\时\n  \\/\\/ event\\.total \\—\\— \\总\\字\\节\\数\\（\\如\\果 lengthComputable \\为 true\\）\n  alert\\(\\`Received \\$\\{event\\.loaded\\} of \\$\\{event\\.total\\}\\`\\)\\;\n\\}\\;\n` }</SyntaxHighlighter>\n<p>关于XHR的Get请求的典型代码(估计现在也用不上了)：</p>\n<SyntaxHighlighter language=\"js\" style={oneLight} showLineNumbers>{ `let xhr \\= new XMLHttpRequest\\(\\)\\;\n\nxhr\\.open\\(\"GET\"\\, \"\\/my\\/url\"\\)\\;\n\nxhr\\.send\\(\\)\\;\n\nxhr\\.onload \\= function \\(\\) \\{\n  if \\(xhr\\.status \\!\\= 200\\) \\{\n    \\/\\/ HTTP error\\?\n    \\/\\/ \\处\\理 error\n    alert\\(\"Error\\: \" \\+ xhr\\.status\\)\\;\n    return\\;\n  \\}\n\n  \\/\\/ \\获\\取\\来\\自 xhr\\.response \\的\\响\\应\n\\}\\;\n\nxhr\\.onprogress \\= function \\(event\\) \\{\n  \\/\\/ \\报\\告\\进\\度\n  alert\\(\\`Loaded \\$\\{event\\.loaded\\} of \\$\\{event\\.total\\}\\`\\)\\;\n\\}\\;\n\nxhr\\.onerror \\= function \\(\\) \\{\n  \\/\\/ \\处\\理\\非 HTTP error\\（\\例\\如\\网\\络\\中\\断\\）\n\\}\\;\n` }</SyntaxHighlighter>\n<h3>上传进度</h3>\n<p>前面提到过，XML可以做到Fetch做不到的跟踪上传进度——xhr.upload</p>\n<p>它会生成事件，类似于 xhr，但是 xhr.upload 仅在上传时触发它们：</p>\n<ul>\n<li>loadstart —— 上传开始。</li>\n<li>progress —— 上传期间定期触发。</li>\n<li>abort —— 上传中止。</li>\n<li>error —— 非 HTTP 错误。</li>\n<li>load —— 上传成功完成。</li>\n<li>timeout —— 上传超时（如果设置了 timeout 属性）。</li>\n<li>loadend —— 上传完成，无论成功还是 error。</li>\n</ul>\n<p>示例：</p>\n<SyntaxHighlighter language=\"js\" style={oneLight} showLineNumbers>{ `xhr\\.upload\\.onprogress \\= function \\(event\\) \\{\n  alert\\(\\`Uploaded \\$\\{event\\.loaded\\} of \\$\\{event\\.total\\} bytes\\`\\)\\;\n\\}\\;\n\nxhr\\.upload\\.onload \\= function \\(\\) \\{\n  alert\\(\\`Upload finished successfully\\.\\`\\)\\;\n\\}\\;\n\nxhr\\.upload\\.onerror \\= function \\(\\) \\{\n  alert\\(\\`Error during the upload\\: \\$\\{xhr\\.status\\}\\`\\)\\;\n\\}\\;\n` }</SyntaxHighlighter>\n<h1>Fetch</h1>\n<p>Fetch是一个现代通用的JS网络请求方法</p>\n<p>它的优点在于：</p>\n<ul>\n<li>支持async/await</li>\n<li>写法简单，api易上手</li>\n<li>脱离了XHR，是ES规范里的实现方法</li>\n</ul>\n<p>但它依旧有缺点：</p>\n<ul>\n<li>浏览器不支持，需要polyfill</li>\n<li>默认无cookie</li>\n<li>HTTP错误不会导致Promise返回reject</li>\n<li>不支持查看上传进度</li>\n<li>不支持超时控制</li>\n</ul>\n<p>接下来让我们看看Fetch的相关流程</p>\n<h2>Fetch基础</h2>\n<p>基本语法：</p>\n<SyntaxHighlighter language=\"js\" style={oneLight} showLineNumbers>{ `let promise \\= fetch\\(url\\, \\[options\\]\\)\\;\n` }</SyntaxHighlighter>\n<p>浏览器立即启动请求，并返回一个该调用代码应该用来获取结果的 promise。\n获取响应通常需要经过两个阶段。</p>\n<p><strong>第一阶段，当服务器发送了响应头（response header），fetch 返回的 promise 就使用内建的 Response class 对象来对响应头进行解析。</strong></p>\n<p>在这个阶段，我们可以通过检查响应头的状态来确认请求是否成功，如果fetch没法成功建立，也就是遇到网络问题等网络本身问题，promise就会reject。</p>\n<blockquote>\n<p>因此一切服务器的返回：404or500等等，都不会导致Promise返回reject，从而难以追踪错误。</p>\n</blockquote>\n<p><strong>第二阶段，为了获取 response body，我们需要使用一个其他的方法调用。</strong></p>\n<p>Response 提供了多种基于 promise 的方法，来以不同的格式访问 body：</p>\n<ul>\n<li><p>response.text() —— 读取 response，并以文本形式返回 response，</p>\n</li>\n<li><p>response.json() —— 将 response 解析为 JSON 格式，</p>\n</li>\n<li><p>response.formData() —— 以 FormData 对象（在 下一章 有解释）的形式返回 response，</p>\n</li>\n<li><p>response.blob() —— 以 Blob（具有类型的二进制数据）形式返回 response，</p>\n</li>\n<li><p>response.arrayBuffer() —— 以 ArrayBuffer（低级别的二进制数据）形式返回 response，</p>\n<p>另外，response.body 是 ReadableStream 对象，它允许你逐块读取 body，GPTpost响应流就是基于此进行流式响应:</p>\n</li>\n</ul>\n<SyntaxHighlighter language=\"js\" style={oneLight} showLineNumbers>{ `const response \\= await fetch\\(\"http\\:\\/\\/192\\.168\\.223\\.26\\:5000\\/chain\"\\, \\{\n  signal\\: aborter\\.signal\\,\n  method\\: \"POST\"\\,\n  headers\\: \\{ \"Content\\-Type\"\\: \"application\\/json\" \\}\\,\n  body\\: JSON\\.stringify\\(\\{\n    prompt\\,\n  \\}\\)\\,\n\\}\\)\\;\nconst reader \\= response\\.body\\.getReader\\(\\)\\;\n` }</SyntaxHighlighter>\n<blockquote>\n<p>我们只能选择一种读取 body 的方法。\n如果我们已经使用了 response.text() 方法来获取 response，那么如果再用 response.json()，则不会生效，因为 body 内容已经被处理过了。</p>\n</blockquote>\n<h1>其他</h1>\n<p>XML：可扩展标记语言（Extensible Markup Language，XML）是一种标记语言。XML是从标准通用标记语言（SGML）中简化修改出来的。</p>\n<p>AJAX: AJAX（Asynchronous JavaScript And XML，异步 JavaScript 和 XML）是一种使用 XMLHttpRequest 技术构建更复杂，动态的网页的编程实践。\n其中实现方法有古早的XHR以及新的Fetch。</p>\n<p>HTTP模块： Http模块指的是node中Http模块，包括：</p>\n<ul>\n<li>http.createServer 担当web服务器</li>\n<li>http.createClient，担当客户端，实现爬虫之类的工作。</li>\n</ul>\n","id":"6"},{"title":"YBG-第六期","date":"2024-03-12","categories":"Weekly","excerpt":"这里是每周总结，记录每一周的趣事，技术分享以及学习生活。","html":"<blockquote>\n<p>本来这周打算鸽了，想了想还是记录一下吧</p>\n</blockquote>\n<h2>Technology/Study</h2>\n<ol>\n<li><p>这周在写i18的时候遇到了一个bug，i18切换语言的时候Header的小幽灵卡住。排查原因后发现是Script组件不会再次执行脚本导致小幽灵卡住。\n但是Next的Script组件官方的解释是：</p>\n<blockquote>\n<p>This script will load and execute when any route in your application is accessed. Next.js will ensure the script will only load once, even if a user navigates between multiple pages.</p>\n</blockquote>\n<blockquote>\n<p>当访问应用程序中的任何路由时，该脚本将加载并执行。 Next.js 将确保脚本仅加载一次，即使用户在多个页面之间导航也是如此。</p>\n</blockquote>\n<p>我在next仓库中也找到了类似的<a href=\"https://github.com/vercel/next.js/issues/62303\">issue</a></p>\n<p>于是乎我放弃了Script的组件，直接将脚本写入了JSX。</p>\n</li>\n<li><p>一个好用的chrome插件，用来判断你的网页seo的好坏\n<a href=\"https://chromewebstore.google.com/detail/meta-seo-inspector/ibkclpciafdglkjkcibmohobjkcfkaef\">https://chromewebstore.google.com/detail/meta-seo-inspector/ibkclpciafdglkjkcibmohobjkcfkaef</a></p>\n</li>\n<li><p>前段时间发现的一个讲述RSC的博客，内容优质，只是更新太慢了，n久了就更新了一章\n<a href=\"https://jessedit.tech/articles/react-server-components/1-background/\">https://jessedit.tech/articles/react-server-components/1-background/</a></p>\n</li>\n<li><p>Rolldown正式发布： <a href=\"https://github.com/rolldown/rolldown\">https://github.com/rolldown/rolldown</a></p>\n</li>\n</ol>\n<h2>Life</h2>\n<ol>\n<li><p><a href=\"https://mp.weixin.qq.com/s/wnOl4iTkVY3HI2wysZck5Q\">&quot;为什么往往都是技术合伙人被踢出局&quot;</a></p>\n</li>\n<li><p>上周去弄了个外服的AppleId，下了个MK-mobile，好像有点上头。</p>\n<p><a href=\"https://zhuanlan.zhihu.com/p/101024418\">教程</a></p>\n<Image src={mkmobile} alt=\"游戏\" \n      sizes=\"100vw\"\n      style={{\n        width: '100%',\n        height: 'auto',\n      }} />\n</li>\n<li><p>一个比赛项目最近准备完工，到时候看看写一下技术要点什么的。</p>\n<p><a href=\"https://github.com/YYGod0120/ai-qa\">ai-qa</a></p>\n<Image src={aiqa} alt=\"网站截图\" \n      sizes=\"100vw\"\n      style={{\n        width: '100%',\n        height: 'auto',\n      }} /></li>\n</ol>\n","id":"11"},{"title":"YBG-第五期","date":"2024-03-04","categories":"Weekly","excerpt":"这里是每周总结，记录每一周的趣事，技术分享以及学习生活。","html":"<blockquote>\n<p>傲不可长，志不可满</p>\n</blockquote>\n<h2>Technology</h2>\n<ol>\n<li><p>为每个开发人员以及IT工作者来说非常有用的工具集合网站，包括不仅限于TOKEN生成器,hash文本,加密等等工具。</p>\n<p><a href=\"https://it-tools.tech/\">https://it-tools.tech/</a></p>\n</li>\n<li><p>一些能提升效率的vscode插件。</p>\n<p><a href=\"https://www.freecodecamp.org/news/best-vscode-extensions/?ref=dailydev\">https://www.freecodecamp.org/news/best-vscode-extensions/?ref=dailydev</a></p>\n</li>\n<li><p>React从类组件到Hook，马上又要到compile时代</p>\n<p><a href=\"https://reacttraining.com/blog/react-19-will-be-compiled?ref=dailydev\">https://reacttraining.com/blog/react-19-will-be-compiled?ref=dailydev</a></p>\n</li>\n<li><p>React 2024年的趋势</p>\n<p><a href=\"https://mp.weixin.qq.com/s/s0-7yD_gspgNX7RYvn_wxA\">https://mp.weixin.qq.com/s/s0-7yD_gspgNX7RYvn_wxA</a></p>\n</li>\n<li><p>Vue十年回顾，来自Even You的演讲</p>\n<p><a href=\"https://mp.weixin.qq.com/s/s0-7yD_gspgNX7RYvn_wxA\">https://mp.weixin.qq.com/s/s0-7yD_gspgNX7RYvn_wxA</a></p>\n</li>\n<li><p>Node.js，2023年回顾。</p>\n<p><a href=\"https://blog.rafaelgss.dev/nodejs-2023-year-in-review\">https://blog.rafaelgss.dev/nodejs-2023-year-in-review</a></p>\n</li>\n</ol>\n<h2>Study</h2>\n<ol>\n<li><p><a href=\"https://typescript-book.vercel.app/zh-cn/?ref=dailydev\">《Concise TypeScript Book》</a>: 一本完全开源免费，全面简洁的涵盖了TypeScript功能的电子书，无论你是新手还是经验丰富的开发人员，本书都是增强您对 TypeScript 的理解和熟练程度的宝贵资源。</p>\n</li>\n<li><p><a href=\"https://interview.poetries.top/\">前端进阶之旅</a>: 不免费，但是内容多，范围广的面试宝典。要说缺点可能就是内容有些比较老，网页优化不行。但总体来说对于准备面试是必不可少的。</p>\n</li>\n</ol>\n<h2>Life</h2>\n<ol>\n<li><p>本周又接到了一个VUE项目，没使用过VUE，但从这一周的体验来说，至少说还能依葫芦画瓢，不愧是适用于没学过前端的快速上手框架</p>\n</li>\n<li><p>闲下来的功夫给博客改了点bug以及新增了英语语言，只是翻译还没完全。</p>\n<p><a href=\"https://react.i18next.com/\">React-i8next</a> 官方网站居然不支持中文😥</p>\n<p><a href=\"https://locize.com/blog/next-app-dir-i18n/\">Next13及以上配置教程</a></p>\n</li>\n<li><p>NodeJS新官网：<a href=\"https://beta-node-js-org.vercel.app/en\">https://beta-node-js-org.vercel.app/en</a></p>\n<Image src={nodejs} alt=\"nodejs新官网\" \n      sizes=\"100vw\"\n      style={{\n        width: '100%',\n        height: 'auto',\n      }} /></li>\n</ol>\n","id":"10"},{"title":"YBG-第四期","date":"2024-02-26","categories":"Weekly","excerpt":"这里是每周总结，记录每一周的趣事，技术分享以及学习生活。","html":"<blockquote>\n<p>这里是每周总结，记录每一周的趣事，技术分享以及学习生活。</p>\n</blockquote>\n<p>开学第一周，不知道是寒假太短还是什么，感觉昨天自己还在准备从学校回家，现在却还躺在学校床上。</p>\n<h2>Technology</h2>\n<ol>\n<li><p>Electron 29.0 发布</p>\n<p><a href=\"https://www.electronjs.org/zh/blog/electron-29-0\">https://www.electronjs.org/zh/blog/electron-29-0</a></p>\n</li>\n<li><p>ECMAScript 2024(ES15)将带来哪些新特性\n<a href=\"https://medium.com/@yourfuse/javascript-whats-new-with-ecmascript-2024-es15-ef056d2f4bf1\">https://medium.com/@yourfuse/javascript-whats-new-with-ecmascript-2024-es15-ef056d2f4bf1</a>\n其中包括新时间api，流水线操作，类元组数据类型等等。</p>\n</li>\n</ol>\n<h2>Study</h2>\n<ol>\n<li><p><a href=\"https://juejin.cn/post/7100830429405511710\">CSS画多边形及clip-path: polygon()属性原理</a>: 我在项目中遇到了需要多边形，甚至需要圆角多边形的需求，比如说如何画一个<a href=\"https://www.cnblogs.com/coco1s/p/15009605.html\">圆角三角形</a>。</p>\n</li>\n<li><p><a href=\"https://www.freecodecamp.org/chinese/news/css-scrollbar-tutorial/\">自定义你的滚动条</a>: 同样是项目推动学习，值得注意的是从chrome121开始也同时支持scrollbar-width 和 scrollbar-color 属性。</p>\n</li>\n</ol>\n<h2>Life</h2>\n<ol>\n<li><p>写了半年多的react，最近接手了一个vue的项目，还是已经停止维护的vue2的项目。ui样式逻辑全部写在一个文件里感觉怪怪的，三四百行找起来也不太舒服。</p>\n</li>\n<li><p>一个寒假结束，东西没学多少，麻将倒是学了不少，福麻川麻，感觉娱乐活动又要+1了。</p>\n</li>\n<li><p>TGA2022年度大作-艾尔登法环DLC发布(2024 年 6 月 21 日)。</p>\n<p><a href=\"https://www.bilibili.com/video/BV1YJ4m1s7Na/?spm_id_from=333.337.search-card.all.click&vd_source=274f48b6b0611e27b3026270d8c916a2\">https://www.bilibili.com/video/BV1YJ4m1s7Na/?spm_id_from=333.337.search-card.all.click&amp;vd_source=274f48b6b0611e27b3026270d8c916a2</a></p>\n</li>\n</ol>\n","id":"12"},{"title":"YBG-第三期","date":"2024-02-19","categories":"Weekly","excerpt":"这里是每周总结，记录每一周的趣事，技术分享以及学习生活。","html":"<blockquote>\n<p>这里是每周总结，记录每一周的趣事，技术分享以及学习生活。</p>\n</blockquote>\n<p><del>开工</del>开学大吉</p>\n<h2>Technology</h2>\n<ol>\n<li><p>每个前端开发者都需要知道的五个CSS2024最新用法：</p>\n<p><a href=\"https://web.dev/articles/5-css-snippets-every-front-end-developer-should-know-in-2024?hl=zh-cn#csshaspotential-beyond-being-a-parent-selector\">https://web.dev/articles/5-css-snippets-every-front-end-developer-should-know-in-2024?hl=zh-cn#csshaspotential-beyond-being-a-parent-selector</a></p>\n</li>\n<li><p>一行CSS升级或者增强你的项目:</p>\n<p><a href=\"https://moderncss.dev/12-modern-css-one-line-upgrades/\">https://moderncss.dev/12-modern-css-one-line-upgrades/</a></p>\n</li>\n<li><p>React19尚未发布，但是其中的一些Hooks我们先来看看：</p>\n<p><a href=\"https://sorrycc.com/react-19-new-hooks/\">https://sorrycc.com/react-19-new-hooks/</a></p>\n</li>\n</ol>\n<h2>Study</h2>\n<ol>\n<li><a href=\"https://peacockindia.mintlify.app/resources/essential-resources\">Better Code Practices</a>：每一段代码被写出来都需要花费精力去维护，我们能做的就是减少维护的代价</li>\n</ol>\n<h2>Life</h2>\n<ol>\n<li><p>上周去看了一部电影《飞驰人生2》， 没看过1其实影响也不大，总体评价还是不错的，值得一看的春节档</p>\n</li>\n<li><p>染上了德州扑克，甚至有点想去澳门实地ALL in一把。</p>\n</li>\n</ol>\n","id":"8"},{"title":"YBG-第二期","date":"2024-02-12","categories":"Weekly","excerpt":"这里是每周总结，记录每一周的趣事，技术分享以及学习生活。","html":"<blockquote>\n<p>这里是每周总结，记录每一周的趣事，技术分享以及学习生活。</p>\n</blockquote>\n<p>在这里祝大家新年快乐~</p>\n<h2>Technology</h2>\n<ol>\n<li><p>utteranc，一个基于 github issue 的评论区组件，比较老了。</p>\n<p><a href=\"https://utteranc.es/\">https://utteranc.es/</a></p>\n<p>新一点评论库的有 gitalk 以及 gitment 等等。</p>\n</li>\n<li><p>Vite 发布 5.1，新增一些运行时 api，还有变得更快了。</p>\n<p><a href=\"https://vitejs.dev/blog/announcing-vite5-1.html\">https://vitejs.dev/blog/announcing-vite5-1.html</a></p>\n</li>\n<li><p>lodash，一个现代的 JavaScript 实用程序库，提供模块化，性能和附加功能。</p>\n<p><a href=\"https://github.com/lodash/lodash?tab=readme-ov-file\">https://github.com/lodash/lodash?tab=readme-ov-file</a></p>\n</li>\n<li><p>shields.io，是一种以 SVG 和光栅格式提供简洁、一致且清晰的徽章的服务，可以轻松包含在 GitHub 自述文件或任何其他网页中。</p>\n<p><a href=\"https://github.com/badges/shields\">https://github.com/badges/shields</a></p>\n</li>\n<li><p>css-loaders,一个纯 css 实现加载的动画库。</p>\n<p><a href=\"https://css-loaders.com/\">https://css-loaders.com/</a></p>\n</li>\n</ol>\n<h2>Study</h2>\n<ol>\n<li><p><a href=\"https://blog.stackademic.com/we-forgot-frontend-basics-2f9a1c4dabaa\">We Forgot Frontend Basics</a>：我们总是忘记了前端基础知识，例如<code>:empty</code>等等。</p>\n</li>\n<li><p><a href=\"https://medium.com/globant/javascript-optimization-techniques-20d8d167dadd\">React &amp; Javascript Optimization Techniques</a>：React 和 Javascript 优化技术，除了我们熟知的防抖节流，memo 函数以及纯函数，其实还有懒加载，虚拟化等等其他优化技术。</p>\n</li>\n</ol>\n<h2>Life</h2>\n<ol>\n<li><p>马上要到发压岁钱的年纪了(苦笑</p>\n</li>\n<li><p>推荐两部电视剧：台剧-我们与恶的距离以及美剧-无耻之徒，一部是深刻批判当今社会的现状，舆论网暴以及媒体的篡改。另一部是简单的爆米花电视剧，芝加哥版家有儿女(稍微少儿不宜)</p>\n<blockquote>\n<p>我们与恶的距离，就在于是声讨恶人，还是声讨恶。</p>\n</blockquote>\n</li>\n</ol>\n","id":"9"},{"title":"YGB-第一期","date":"2024-02-05","categories":"Weekly","excerpt":"这里是每周总结，记录每一周的趣事，技术分享以及学习生活。","html":"<blockquote>\n<p>这里是每周总结，记录每一周的趣事，技术分享以及学习生活。</p>\n</blockquote>\n<p>这个周刊的主要目的就是记录生活，分享技术以及当作一个小小的备忘录。\n也希望每周能顺利更新，先浅浅定个 15 期的目标。</p>\n<h2>Technology</h2>\n<ol>\n<li><p>一个有趣的烟花跟随样式</p>\n<p><a href=\"https://codepen.io/leimapapa/pen/XWGMrvo\">https://codepen.io/leimapapa/pen/XWGMrvo</a></p>\n<Image src={SparkleMotion} alt=\"Sparkle Motion\" \n      sizes=\"100vw\"\n      style={{\n        width: '100%',\n        height: 'auto',\n      }} />\n</li>\n<li><p>一只有趣的幽灵(也是我博客上的那只)</p>\n<p><a href=\"https://codepen.io/supah/pen/OBbzvp\">https://codepen.io/supah/pen/OBbzvp</a></p>\n<Image src={GhostCursor} alt=\"Ghost Cursor\" \n      sizes=\"100vw\"\n      style={{\n        width: '100%',\n        height: 'auto',\n      }} />\n</li>\n<li><p>Shiki：一个类似于 Highlight.js 的语法高亮器。</p>\n<p><a href=\"https://shiki-zh-docs.vercel.app/\">https://shiki-zh-docs.vercel.app/</a>\n博客用<code>react-syntax-highlighter</code>语法高亮组件,使用 prismjs 或者 highlightjs 进行封装。新旧程度肯定不如 Shiki 新。</p>\n</li>\n<li><p>一个页面灵感的网站，会点设计对自己开发有不少帮助。\n<a href=\"https://uxchi.notion.site/UI-Inspiration-881b4c0179a74935a3f607ad3521cdb5\">https://uxchi.notion.site/UI-Inspiration-881b4c0179a74935a3f607ad3521cdb5</a></p>\n</li>\n</ol>\n<h2>Study</h2>\n<ol>\n<li><p><a href=\"https://ishadeed.com/article/target-size#for-designers-delivering-a-clear-target-size-spec\">设计更好的目标尺寸</a>：作为用户，我们总是要和按钮，链接以及卡片等等 UI 进行交互，一旦这些东西的大小不对，就会造成很大的困扰。作为前端开发，我们有必要了解一下一些设计方面的知识。</p>\n</li>\n<li><p><a href=\"https://arendjr.nl/2023/04/mvp-the-most-valuable-programmer\">The Most Valuable Programmer</a>： 如何做一个 MVP 程序员，绝不是写最多的代码，也不是写最有价值的代码，而是成为一个最好的自己。</p>\n</li>\n</ol>\n<h2>Life</h2>\n<ol>\n<li><p><a href=\"https://yyblog-gamma.vercel.app/\">NewBlog</a>：新博客搭建完备，功能不多，后面再说。预计年前替换之前那个旧博客。对这个博客感兴趣的可以去看看 github 上的代码仓库。</p>\n</li>\n<li><p>幻兽帕鲁火爆全中国，身边就没有没在玩的。98 大洋购入后 2 天疯玩 20 小时后又感觉索然无味，等后续更新了。</p>\n<Image src={gametime} alt=\"=game-time\" \n      sizes=\"100vw\"\n      style={{\n        width: '100%',\n        height: 'auto',\n      }} /></li>\n</ol>\n","id":"13"},{"title":"NewBlog","date":"2024-02-03","categories":"Project","excerpt":"有一个由自己打造的博客，是每个前端开发必备项目。我通过半个月时间，尝试Next搭建了一个博客。","html":"<h1>前言</h1>\n<p>原本，我利用 Hexo 搭建了一个个人博客，刚开始还挺新鲜的，但慢慢就觉得样式单调，而且我想加入评论以及流量监控很麻烦。所以想着要不自己手写一个，更好控制也能自定义样式。于是 yyblog 就孕育而生</p>\n<h1>结构</h1>\n<p>整个博客，不仅仅由 yyblog 组成，还有 ybg-cli 脚手架，用于自动创建删除文章以及编译文章。</p>\n<ul>\n<li><p><strong>yyblog</strong></p>\n<ul>\n<li>Nextjs</li>\n<li>typescript</li>\n<li>tailwind</li>\n<li>react-syntax-highlighter</li>\n</ul>\n</li>\n<li><p><strong>ybg-cli</strong></p>\n<ul>\n<li>cac</li>\n<li>gray-matter</li>\n<li>he</li>\n</ul>\n</li>\n</ul>\n<h2>yyblog</h2>\n<p>采用<code>Nextjs</code>+<code>Typescript</code>+<code>Tailwindw</code>为主要技术。</p>\n<p>效仿 Hexo 采用纯前端，文章编写删除编译都在本地运行，对前端工程师更友好。\nNextjs 同时也支持全栈开发。简单的 sql 语句也能够对文章进行增删改查。</p>\n<p>Next 提供的文件路由同时也可以帮我们自定义一些特殊页面，常见的 layout 页面，404 页面以及错误页面等等。</p>\n<blockquote>\n<p>避免中文命名文件！！</p>\n</blockquote>\n<p>除了文件路由以外，Next 也提供了很多组件以及优化，比如 <code>font</code>，<code>&lt;Image&gt;</code>标签还有<code>&lt;Script&gt;</code>标签。\n这里说一下<code>&lt;Script&gt;</code>，博客网站上我放了一些动画(来源于 codepen),而这些动画<code>script</code>脚本，放入 <code>tsx(jsx)</code> 中只能通过<code>dangerouslySetInnerHTML</code>这个极具风险的 attribute\n但正好 Nextjs 提供了一个<code>&lt;Script&gt;</code>，能够让我们使用脚本组件。</p>\n<h2>ybg-cli</h2>\n<p>采用纯前端的重点就在于文章的生成删除以及编译，麻烦就麻烦在编译成 TSX 代码插入到 yyblog 中形成页面。</p>\n<p>光看文字不如上点代码：</p>\n<SyntaxHighlighter language=\"typescript\" style={oneLight} showLineNumbers>{ `export async function compileFile\\(\\)\\: Promise\\<mdFile\\[\\]\\> \\{\n  let compiledFiles\\: mdFile\\[\\] \\= \\[\\]\\;\n  const fileList \\= fs\\.readdirSync\\(_postFolder\\)\\;\n  for \\(const file of fileList\\) \\{\n    const filePath \\= path\\.join\\(_postFolder\\, file\\)\\;\n    const fileContent \\= fs\\.readFileSync\\(filePath\\, \"utf\\-8\"\\)\\;\n    const parsedFile \\= matter\\(fileContent\\)\\;\n    const newMatter \\= \\{\n      \\.\\.\\.parsedFile\\,\n      data\\: \\{ \\.\\.\\.parsedFile\\.data\\, date\\: UTCToString\\(parsedFile\\.data\\.date\\) \\}\\,\n    \\}\\;\n    const picPath \\= makeImportPic\\(await marked\\(parsedFile\\.content\\)\\)\\;\n    const htmlText \\= HtmlToNext\\(await marked\\(parsedFile\\.content\\)\\)\\;\n    compiledFiles\\.push\\(\n      picPath\n        \\? \\{\n            mdMatter\\: newMatter\\,\n            mdHtml\\: htmlText\\,\n            other\\: \\{\n              picPath\\: picPath\\,\n            \\}\\,\n          \\}\n        \\: \\{ mdMatter\\: newMatter\\, mdHtml\\: htmlText \\}\\,\n    \\)\\;\n  \\}\n  return compiledFiles\\;\n\\}\n` }</SyntaxHighlighter>\n<p>读取文件并且用 gray-matter 解析 md 文件生成对应的内容。\n<code>mdMatter</code>是文章头部<code>yaml</code>格式内容的解析。\n<code>mdHtml</code>是文章主题部分的解析。\n<code>other</code>是解析成 Html 后需要插入到最后 TSX 内容的东西。</p>\n<p>重点在于<code>HtmlToNext</code>函数:</p>\n<SyntaxHighlighter language=\"tsx\" style={oneLight} showLineNumbers>{ `import he from \"he\"\\;\nfunction ImageRepimg\\(html\\: string\\) \\{\n  const processedHtml \\= html\\.replace\\(\n    \\/\\<img\\\\s\\+src\\=\"\\(\\.\\*\\?\\)\"\\\\s\\+alt\\=\"\\(\\.\\*\\?\\)\"\\.\\*\\?\\\\\\/\\>\\/g\\,\n    function \\(match\\, src\\, alt\\) \\{\n      const modifiedSrc \\= src\\.split\\(\"\\/\"\\)\\;\n      const newSrc \\= modifiedSrc\\[modifiedSrc\\.length \\- 1\\]\\; \\/\\/\\修\\改\\后\\的SRC\n\n      const modifiedAlt \\= alt\\; \\/\\/ \\修\\改\\后\\的alt\n\n      return \\`\\<Image src\\=\\{\\$\\{newSrc\\.slice\\(\n        0\\,\n        newSrc\\.lastIndexOf\\(\"\\.\"\\)\\,\n      \\)\\}\\} alt\\=\"\\$\\{modifiedAlt\\}\" \n      sizes\\=\"100vw\"\n      style\\=\\{\\{\n        width\\: '100\\%'\\,\n        height\\: 'auto'\\,\n      \\}\\} \\/\\>\\`\\;\n    \\}\\,\n  \\)\\;\n  return processedHtml\\;\n\\}\nfunction replaceClassName\\(html\\: string\\) \\{\n  const processedHtml \\= html\\.replace\\(\\/className\\=\\/g\\, \"className\\=\"\\)\\;\n  return processedHtml\\;\n\\}\nfunction highLightHtml\\(html\\: string\\) \\{\n  \\/\\/ \\在\\代\\码\\块\\内\\的\\特\\殊\\字\\符\\前\\加\\上 \\\\\n  const replacedString1 \\= html\\.replace\\(\n    \\/\\<pre\\>\\<code className\\=\"language\\-\\(\\\\w\\+\\)\"\\>\\(\\[\\\\s\\\\S\\]\\*\\?\\)\\<\\\\\\/code\\>\\<\\\\\\/pre\\>\\/g\\,\n    \\(_\\, language\\, codeContent\\) \\=\\> \\{\n      \\/\\/\\转\\义\\符\\删\\除\n      const decodeCode \\= he\\.decode\\(codeContent\\)\\;\n      const codeWithBackslash \\= decodeCode\\.replace\\(\\/\\(\\[\\^\\\\w\\\\s\"'\\]\\)\\/g\\, \"\\\\\\\\\\$1\"\\)\\;\n      return \\`\\<SyntaxHighlighter language\\=\"\\$\\{language\\}\" style\\=\\{oneLight\\} showLineNumbers\\>\\{ \\\\\\`\\$\\{codeWithBackslash\\}\\\\\\` \\}\\<\\/SyntaxHighlighter\\>\\`\\;\n    \\}\\,\n  \\)\\;\n\n  return replacedString1\\;\n\\}\nexport function HtmlToNext\\(html\\: string\\) \\{\n  \\/\\/\\替\\换img\\标\\签\n  const step1Html \\= ImageRepimg\\(html\\)\\;\n  \\/\\/\\替\\换class\\为className\n  const step2Html \\= replaceClassName\\(step1Html\\)\\;\n  \\/\\/\\高\\亮\\代\\码\n  const step3Html \\= highLightHtml\\(step2Html\\)\\;\n  \\/\\/\\闭\\合\\分\\割\\线\n  const step4Html \\= step3Html\\.replace\\(\\/\\<hr\\>\\/g\\, \"\\<hr \\/\\>\"\\)\\;\n  return step4Html\\;\n\\}\n` }</SyntaxHighlighter>\n<p>通过对解析后 html 的修改，主要是用正则，实现 html 向 TSX(Next)的转化。</p>\n<h1>3月4号更新：</h1>\n<p>更新了英文版，主要采用的是Next的中间件-<code>middleware.js</code>以及<code>react-i18next</code>和<code>i18next</code>,这两个库i18n转化库。</p>\n<p>配置的教程在<a href=\"https://locize.com/blog/next-app-dir-i18n/\">这里</a></p>\n<SyntaxHighlighter language=\"javascript\" style={oneLight} showLineNumbers>{ `import \\{ NextResponse \\} from \"next\\/server\"\\;\nimport acceptLanguage from \"accept\\-language\"\\;\nimport \\{ fallbackLng\\, languages\\, cookieName \\} from \"\\@\\/app\\/i18n\\/setting\"\\;\n\nacceptLanguage\\.languages\\(languages\\)\\;\n\nexport const config \\= \\{\n  \\/\\/ matcher\\: '\\/\\:lng\\*'\n  matcher\\: \\[\"\\/\\(\\(\\?\\!api\\|_next\\/static\\|_next\\/image\\|imgs\\|favicon\\.ico\\|sw\\.js\\)\\.\\*\\)\"\\]\\,\n\\}\\;\nexport function middleware\\(req\\) \\{\n  let lng\\;\n  if \\(req\\.cookies\\.has\\(cookieName\\)\\)\n    lng \\= acceptLanguage\\.get\\(req\\.cookies\\.get\\(cookieName\\)\\.value\\)\\;\n  if \\(\\!lng\\) lng \\= acceptLanguage\\.get\\(req\\.headers\\.get\\(\"Accept\\-Language\"\\)\\)\\;\n  if \\(\\!lng\\) lng \\= fallbackLng\\;\n\n  \\/\\/ Redirect if lng in path is not supported\n\n  if \\(\n    \\!languages\\.some\\(\\(loc\\) \\=\\> req\\.nextUrl\\.pathname\\.startsWith\\(\\`\\/\\$\\{loc\\}\\`\\)\\) \\&\\&\n    \\!req\\.nextUrl\\.pathname\\.startsWith\\(\"\\/_next\"\\)\n  \\) \\{\n    return NextResponse\\.redirect\\(\n      new URL\\(\\`\\/\\$\\{lng\\}\\$\\{req\\.nextUrl\\.pathname\\}\\`\\, req\\.url\\)\\,\n    \\)\\;\n  \\}\n  if \\(req\\.headers\\.has\\(\"referer\"\\)\\) \\{\n    const refererUrl \\= new URL\\(req\\.headers\\.get\\(\"referer\"\\)\\)\\;\n    const lngInReferer \\= languages\\.find\\(\\(l\\) \\=\\>\n      refererUrl\\.pathname\\.startsWith\\(\\`\\/\\$\\{l\\}\\`\\)\\,\n    \\)\\;\n    const response \\= NextResponse\\.next\\(\\)\\;\n    if \\(lngInReferer\\) response\\.cookies\\.set\\(cookieName\\, lngInReferer\\)\\;\n    return response\\;\n  \\}\n\n  return NextResponse\\.next\\(\\)\\;\n\\}\n` }</SyntaxHighlighter>\n<p>这一段是中间件主要的代码，作用是用户使用不支持语言时自动跳转到默认语言，记住用户每次结束后使用的语言。</p>\n<p><strong>注意:</strong></p>\n<SyntaxHighlighter language=\"js\" style={oneLight} showLineNumbers>{ `export const config \\= \\{\n  \\/\\/ matcher\\: '\\/\\:lng\\*'\n  matcher\\: \\[\"\\/\\(\\(\\?\\!api\\|_next\\/static\\|_next\\/image\\|imgs\\|favicon\\.ico\\|sw\\.js\\)\\.\\*\\)\"\\]\\,\n\\}\\;\n` }</SyntaxHighlighter>\n<p><code>matcher</code>匹配器用于使得中间件在特定的路径上执行。\n这个字符串是负向预测先行，用于匹配不包含以上内容的字符串片段，你需要稍微修改正则以匹配你的文件目录。</p>\n<h1>附件</h1>\n<blockquote>\n<p>一些使用到的库或者代码：</p>\n</blockquote>\n<ul>\n<li><a href=\"https://github.com/jonschlinkert/gray-matter\">gray-matter</a>：解析静态网页元数据</li>\n<li><a href=\"https://github.com/markedjs/marked\">marked</a>：转化<code>md</code>文件为 HTML</li>\n<li><a href=\"https://github.com/isaacs/rimraf\">rimraf</a>：快捷删除文件夹及其内容</li>\n<li><a href=\"https://github.com/egoist/tsup\">tsup</a>：快速构建 TypeScript 项目的工具</li>\n<li><a href=\"https://github.com/alexeyraspopov/picocolors\">picocolors</a>：命令行颜色</li>\n<li><a href=\"https://github.com/cacjs/cac\">cac</a>：构建命令行工具的 JavaScript/TypeScript 框架</li>\n<li><a href=\"https://codepen.io/\">codepen</a>： 动画及特别的 404 页面都来源于此</li>\n<li><a href=\"https://github.com/i18next/react-i18next\">react-i18next</a> i18n for react</li>\n</ul>\n","id":"2"},{"title":"我的2023","date":"2024-01-01","categories":"Life","excerpt":"2023年终总结","html":"<blockquote>\n<p>这是我的第一篇年末总结。</p>\n</blockquote>\n<p>2023 年完美谢幕，说不上万事如意，好在结果令人满意。</p>\n<p>在过去的一年里：</p>\n<ul>\n<li>写了二十八篇博客</li>\n<li>去了两个城市</li>\n<li>看过了六部电影，八部电视剧，零本书</li>\n<li>完成了六个前端项目</li>\n</ul>\n<h1>关于 2023</h1>\n<p>今年的成长相比较与去年，好比从 0 到 1 与从 1 到 10 的区别。\n年初还是一个刚入门甚至都不算入门的 FEer，到年末成为一名入门级 FEer。\n途径无数项目鞭打，有考核的，有学校的甚至还有政府的。</p>\n<Image src={music} alt=\"拙劣的模仿\" \n      sizes=\"100vw\"\n      style={{\n        width: '100%',\n        height: 'auto',\n      }} />\n<Image src={venue} alt=\"后台管理\" \n      sizes=\"100vw\"\n      style={{\n        width: '100%',\n        height: 'auto',\n      }} />\n\n<p>学业方面，没有挂科是基本要求，额外之喜是一份最低等的奖学金。\n<Image src={study} alt=\"学分统计\" \n      sizes=\"100vw\"\n      style={{\n        width: '100%',\n        height: 'auto',\n      }} /></p>\n<p>在过去的一年里还有很多值得纪念的事情，比如武汉和长沙。\n<Image src={wuhan} alt=\"武汉\" \n      sizes=\"100vw\"\n      style={{\n        width: '100%',\n        height: 'auto',\n      }} />\n<Image src={changsha} alt=\"长沙\" \n      sizes=\"100vw\"\n      style={{\n        width: '100%',\n        height: 'auto',\n      }} /></p>\n<p>第一本纪念相册，第一次在外面跨年，第一次一个人生病去大医院看病。</p>\n<p>最后贴上今年的 Github 总结\n<Image src={YYGod0120} alt=\"github年度总结\" \n      sizes=\"100vw\"\n      style={{\n        width: '100%',\n        height: 'auto',\n      }} /></p>\n<h1>关于 2024</h1>\n<p>新的一年，要有新的期望：</p>\n<ul>\n<li>身体健康，万事如意</li>\n<li>从 10 到 100，好好沉淀</li>\n<li>找个大厂实习，接受社会拷打</li>\n<li>更爱爱我的人</li>\n<li>更加投入到我的健身事业中</li>\n<li>读三本书</li>\n<li>别挂科</li>\n</ul>\n","id":"15"},{"title":"RSC","date":"2023-12-04","categories":"Technology","excerpt":"What is RSC, and how it works","html":"<p>推荐阅读：</p>\n<p><a href=\"https://chentsulin.medium.com/react-%E6%96%B0%E6%A6%82%E5%BF%B5-server-components-d632f9a18463\">React 新概念-服务器组件</a></p>\n<p><a href=\"https://www.plasmic.app/blog/how-react-server-components-work\">How React server components work: an in-depth guide</a></p>\n<p><a href=\"https://legacy.reactjs.org/blog/2020/12/21/data-fetching-with-react-server-components.html\">引入零捆绑大小的 React 服务器组件</a></p>\n<h1>前言</h1>\n<p>在笔者刚了解到 RSC(React Service Component)的时候，笔者总是把他和 SSR(Service-Side Render)混为一谈，其实他们完全就是两个概念。</p>\n<p>SSR 代表的是一种渲染方式，与之对应的是 CSR(Client-Side Render),SSR 是一种利于 SEC，加快首屏渲染减少白屏时间的解决方案，被称之为服务端渲染。\n我在这篇文章中并不会提到相关内容，如果感兴趣可以去阅读<a href=\"https://github.com/yacan8/blog/issues/30\">彻底理解服务端渲染-SSR</a></p>\n<p>本篇文章的重点，是 RSC</p>\n<h1>什么是 RSC</h1>\n<p>早在 2020 年年末，React 官方放出了一个演讲和一段演示，主要内容就是关于 RSC，一种零捆绑大小的 React 服务端组件，致力于解决现阶段的两个问题：</p>\n<ul>\n<li>应用程序中日益增加的捆绑包大小</li>\n<li>缓慢的网络请求</li>\n</ul>\n<h1>服务端组件和客户端组件的区别</h1>\n<p>你可以通过<code>use service</code>或者<code>use client</code>来告诉 React 你想用服务端组件还是客户端组件</p>\n<SyntaxHighlighter language=\"jsx\" style={oneLight} showLineNumbers>{ `\"use client\"\\;\n\nimport \\{ useRef\\, useEffect \\} from \"react\"\\;\n\nexport default function Circle\\(\\) \\{\n  const ref \\= useRef\\(null\\)\\;\n  useLayoutEffect\\(\\(\\) \\=\\> \\{\n    const canvas \\= ref\\.current\\;\n    const context \\= canvas\\.getContext\\(\"2d\"\\)\\;\n    context\\.reset\\(\\)\\;\n    context\\.beginPath\\(\\)\\;\n    context\\.arc\\(100\\, 75\\, 50\\, 0\\, 2 \\* Math\\.PI\\)\\;\n    context\\.stroke\\(\\)\\;\n  \\}\\)\\;\n  return \\<canvas ref\\=\\{ref\\} \\/\\>\\;\n\\}\n` }</SyntaxHighlighter>\n<SyntaxHighlighter language=\"jsx\" style={oneLight} showLineNumbers>{ `\"use server\"\\;\n\nexport default async function requestUsername\\(formData\\) \\{\n  const username \\= formData\\.get\\(\"username\"\\)\\;\n  if \\(canRequest\\(username\\)\\) \\{\n    \\/\\/ \\.\\.\\.\n    return \"successful\"\\;\n  \\}\n  return \"failed\"\\;\n\\}\n` }</SyntaxHighlighter>\n<p>当然在一个应用程序中你可以混用两种组件,就像这样：</p>\n<Image src={reactservercomponents} alt=\"react-server-components\" \n      sizes=\"100vw\"\n      style={{\n        width: '100%',\n        height: 'auto',\n      }} />\n\n<p>但值得注意的是，你只能在服务器组件中调用服务器组件或者客户端组件，而客户端组件只能调用客户端组件不能调用服务器组件:</p>\n<SyntaxHighlighter language=\"jsx\" style={oneLight} showLineNumbers>{ `\\/\\/ \\不\\可\n\"use client\"\\;\nimport ServerComponent from \"\\.\\/ServerComponent\\.js\"\\;\nexport default function ClientComponent\\(\\) \\{\n  return \\(\n    \\<div\\>\n      \\<ServerComponent \\/\\>\n    \\<\\/div\\>\n  \\)\\;\n\\}\n` }</SyntaxHighlighter>\n<p>等等，不是说客户端组件不能调用服务器端组件吗?那是怎么做到上面那张图中的树结构中把服务器端组件(orange)挂在客户端组件(blue)上的？</p>\n<p>虽然说我们不能直接 import 服务器组件在客户端组件中，但是我们可以 props 传入的方法将暂时不知道是什么的 ReactNode 作为 props 传给到客户端组件中，而这些 ReactNode 也许就是服务器端组件：</p>\n<SyntaxHighlighter language=\"jsx\" style={oneLight} showLineNumbers>{ `\\/\\/ ClientComponent\\.jsx\n'use client'\nexport default function ClientComponent\\(\\{ children \\}\\) \\{\n  return \\(\n    \\<div\\>\n      \\<h1\\>Hello from client land\\<\\/h1\\>\n      \\{children\\}\n    \\<\\/div\\>\n  \\)\\;\n\\}\n\n\\/\\/ ServerComponent\\.jsx\n'use server'\nexport default function ServerComponent\\(\\) \\{\n  return \\(\n      \\<span\\>Hello from server land\\<\\/span\\>\n  \\)\\;\n\\}\n\n\\/\\/ OuterServerComponent\\.jsx\n\\/\\/ OuterServerComponent \\可\\以\\支\\援\\客\\戶\\端\\和\\伺\\服\\器\\元\\件\\實\\例\\化\n\\/\\/ \\我\\們\\把 \\<ServerComponent \\/\\> \\作\\為 children \\傳\\入\n'use service'\nimport ClientComponent from '\\.\\/ClientComponent'\\;\nimport ServerComponent from '\\.\\/ServerComponent'\\;\nexport default function OuterServerComponent\\(\\) \\{\n  return \\(\n    \\<ClientComponent\\>\n        \\<ServerComponent \\/\\>\n    \\<\\/ClientComponent\\>\n  \\)\\;\n\\}\n` }</SyntaxHighlighter>\n<p>这样就实现了在外部的 service 组件中传入了一个客户端组件，而这个客户端组件下挂载了一个服务端组件，实现了上图的树形结构</p>\n<h1>RSC 是如何渲染的</h1>\n<p>简单的来说：当 React 想要渲染某个服务器组件的时候，会发送一个请求给服务器，携带着各种信息来确定所要渲染的组件及其属性，然后服务器会将这些组件序列化成 JSON 格式再返回给客户端，在客户端上再反序列化，最终呈现出来。</p>\n<p>接下来我们近一步了解一下 RSC 渲染的生命周期</p>\n<h2>RSC 渲染的生命周期</h2>\n<p>注意：以下内容来源于<a href=\"https://www.plasmic.app/blog/how-react-server-components-work\">这篇文章</a>\n我对其进行了一点自己的翻译，但感觉依旧晦涩难懂，如果不感兴趣可以直接跳过</p>\n<h3>1. 服务器收到渲染请求</h3>\n<p>在上面我们提到过客户端组件是没法引入服务端组件的，所以我们的 RSC 页面将始终以服务器端组件开头。根组件始终是服务器端组件。\n当我们开始准备渲染时，我们将会发送特定的请求到特定的 url 上，服务器通过我们发送的请求，根据信息来确定要使用的服务器组件。</p>\n<h3>2. 服务器将根组件元素序列化为 JSON</h3>\n<p>这里的最终目标是将初始根服务器组件呈现为基本 html 标记和客户端组件“占位符”的树。然后，我们可以 JSON 化这棵树，将其发送到浏览器，浏览器可以对其进行反 JSON，用真实的客户端组件填充客户端占位符，并呈现最终结果。</p>\n<p>还记得上面写到的一个<code>&lt;OuterServerComponent/&gt;</code>组件吗，如果我们要渲染这个服务端组件，是将其直接<code>JSON.stringfy()</code>吗？</p>\n<p>差不多，但不完全是！回想一下其实 React 元素就是一个对象，字段 type 可以是字符串，要么是基本 html 标签，比如 <code>div</code> - 或者是一个函数——对于 React 组件实例。</p>\n<SyntaxHighlighter language=\"js\" style={oneLight} showLineNumbers>{ `\\/\\/ React element for \\<div\\>oh my\\<\\/div\\>\n\\> React\\.createElement\\(\"div\"\\, \\{ title\\: \"oh my\" \\}\\)\n\\{\n  \\$\\$typeof\\: Symbol\\(react\\.element\\)\\,\n  type\\: \"div\"\\,\n  props\\: \\{ title\\: \"oh my\" \\}\\,\n  \\.\\.\\.\n\\}\n\n\\/\\/ React element for \\<MyComponent\\>oh my\\<\\/MyComponent\\>\n\\> function MyComponent\\(\\{children\\}\\) \\{\n    return \\<div\\>\\{children\\}\\<\\/div\\>\\;\n  \\}\n\\> React\\.createElement\\(MyComponent\\, \\{ children\\: \"oh my\" \\}\\)\\;\n\\{\n  \\$\\$typeof\\: Symbol\\(react\\.element\\)\\,\n  type\\: MyComponent  \\/\\/ reference to the MyComponent function\n  props\\: \\{ children\\: \"oh my\" \\}\\,\n  \\.\\.\\.\n\\}\n` }</SyntaxHighlighter>\n<p>但是一个函数是没法被 JSON 序列化的，所以 React 提供了一个特殊的替换函数去被 JSON 序列化。\n你可以在<a href=\"https://github.com/facebook/react/blob/42c30e8b122841d7fe72e28e36848a6de1363b0c/packages/react-server/src/ReactFlightServer.js#L368\">ReactFlightServer.js</a>中找一个 <code>resolveModelToJSON()</code> 函数，就是特殊的替换函数。</p>\n<p>所以，当我们序列化根组件的时候，就会遇到三种不同的 React 元素</p>\n<ul>\n<li>如果是个普通的 HTML 标签元素(就像<code>&lt;div&gt;</code>)，那么没事，它已经是 <code>div</code> 可序列化的了！没什么特别可做的。</li>\n<li>如果是一个服务器组件元素，则和渲染根组件一样通过请求传递信息给服务器，调用对应的服务器组件并且接着进行序列化</li>\n<li>如果是一个客户端组件元素，实际上它也已经可以序列化了，他的 type 指向的就是<strong>模块引用对象</strong>而非组件函数。</li>\n</ul>\n<h4>什么是模块引用对象</h4>\n<p>RSC 为 React 元素 type 的字段引入了一个新的可能值，称为“模块引用”;它不是组件函数，而是对它的可序列化“引用”。\n例如，元素 <code>ClientComponent</code> 可能如下所示：</p>\n<SyntaxHighlighter language=\"JS\" style={oneLight} showLineNumbers>{ `\\{\n  \\$\\$typeof\\: Symbol\\(react\\.element\\)\\,\n  \\/\\/ The type field  now has a reference object\\,\n  \\/\\/ instead of the actual component function\n  type\\: \\{\n    \\$\\$typeof\\: Symbol\\(react\\.module\\.reference\\)\\,\n    \\/\\/ ClientComponent is the default export\\.\\.\\.\n    name\\: \"default\"\\,\n    \\/\\/ from this file\\!\n    filename\\: \"\\.\\/src\\/ClientComponent\\.client\\.js\"\n  \\}\\,\n  props\\: \\{ children\\: \"oh my\" \\}\\,\n\\}\n` }</SyntaxHighlighter>\n<p>我们将对客户端组件函数的引用转换为可序列化的“模块引用”对象要借助于外界。\nReact 团队已经发布了对 webpack 的官方 RSC 支持， react-server-dom-webpack 作为 webpack 加载器或节点寄存器。\n当服务器组件从 <code>\\*.client.jsx</code> 文件中导入某些内容时，它不是实际获取该内容，而是仅获取一个模块引用对象，其中包含该内容的文件名和导出名称。在服务器上构建的 React 树中，从来没有任何客户端组件函数！\n再次考虑上面的例子，我们试图序列化 <code>&lt;OuterServerComponent  /&gt;</code> ;我们最终会得到一个 JSON 树，如下所示：</p>\n<SyntaxHighlighter language=\"js\" style={oneLight} showLineNumbers>{ `\\{\n  \\/\\/ The ClientComponent element placeholder with \"module reference\"\n  \\$\\$typeof\\: Symbol\\(react\\.element\\)\\,\n  type\\: \\{\n    \\$\\$typeof\\: Symbol\\(react\\.module\\.reference\\)\\,\n    name\\: \"default\"\\,\n    filename\\: \"\\.\\/src\\/ClientComponent\\.client\\.js\"\n  \\}\\,\n  props\\: \\{\n    \\/\\/ children passed to ClientComponent\\, which was \\<ServerComponent \\/\\>\\.\n    children\\: \\{\n      \\/\\/ ServerComponent gets directly rendered into html tags\\;\n      \\/\\/ notice that there's no reference at all to the\n      \\/\\/ ServerComponent \\- we're directly rendering the \\`span\\`\\.\n      \\$\\$typeof\\: Symbol\\(react\\.element\\)\\,\n      type\\: \"span\"\\,\n      props\\: \\{\n        children\\: \"Hello from server land\"\n      \\}\n    \\}\n  \\}\n\\}\n` }</SyntaxHighlighter>\n<p>离开模块引用对象，回到序列化根组件,在这个过程的最后，我们得到这样一个 React 树：\n<Image src={reactservercomponentsplaceholders} alt=\"react-server-components-placeholders\" \n      sizes=\"100vw\"\n      style={{\n        width: '100%',\n        height: 'auto',\n      }} />\n它将被发送到浏览器上以完成最后一步</p>\n<p>还有一点需要记住，因为我们要序列化整个 React 树，所以我们传递的 props 也得是能被序列化的，这意味着从服务器组件中，您不能将事件处理程序作为 prop 传递下来！</p>\n<SyntaxHighlighter language=\"js\" style={oneLight} showLineNumbers>{ `\\/\\/ NOT OK\\: server components cannot pass functions as a prop\n\\/\\/ to its descendents\\, because functions are not serializable\\.\nfunction SomeServerComponent\\(\\) \\{\n  return \\<button onClick\\=\\{\\(\\) \\=\\> alert\\(\"OHHAI\"\\)\\}\\>Click me\\!\\<\\/button\\>\\;\n\\}\n` }</SyntaxHighlighter>\n<p>但是，当我们遇到客户端组件时，我们从不调用客户端组件函数，因此，如果您有一个实例化另一个客户端组件的客户端组件：</p>\n<SyntaxHighlighter language=\"js\" style={oneLight} showLineNumbers>{ `function SomeServerComponent\\(\\) \\{\n  return \\<ClientComponent1\\>Hello world\\!\\<\\/ClientComponent1\\>\\;\n\\}\n\nfunction ClientComponent1\\(\\{children\\}\\) \\{\n  \\/\\/ It is okay to pass a function as prop from client to\n  \\/\\/ client components\n  return \\<ClientComponent2 onChange\\=\\{\\.\\.\\.\\}\\>\\{children\\}\\<\\/ClientComponent2\\>\\;\n\\}\n` }</SyntaxHighlighter>\n<p><code>ClientComponent2</code> 根本没有出现在这个 RSC-JSON 树中;相反，我们只会看到一个带有模块引用和 <code>props</code> 的 <code>ClientComponent1</code> 元素。因此，将事件处理程序作为道具传递给 <code>ClientComponent2</code> 是完全合法的</p>\n<h3>3. 浏览器重构 React 树</h3>\n<p>终于到了我们的最后一步：\n浏览器接收来自服务器的 JSON 输出，现在必须开始重建要在浏览器中呈现的 React 树。每当我们遇到一个元素 type 是模块引用时，我们都会希望将其替换为对真实客户端组件函数的引用。\n这个工作依旧需要外界的帮助，他们帮我们将服务器上的模块引用替换了客户端组件函数，现在同样可以用浏览器中真正的客户端组件函数替换这些模块引用。\n重建的 React 树将如下所示——只交换了原生标签和客户端组件：\n<Image src={reactservercomponentsclient} alt=\"react-server-components-client\" \n      sizes=\"100vw\"\n      style={{\n        width: '100%',\n        height: 'auto',\n      }} />\n然后我们像往常一样渲染并将这棵树提交到 DOM 中！</p>\n<h2>关于 Suspense</h2>\n<p>Suspense 是一个 React 组件，是专门用于 RSC 的一个组件\nSuspense 允许你在 React 组件需要一些尚未准备好的东西（获取数据、延迟导入组件等）时抛出 promise 。这些 promise 被捕获在“Suspense 边界”——每当渲染 Suspense 子树抛出 promise 时，React 都会暂停渲染该子树，直到 promise 被解析，然后重试。\n多亏了 Suspense，您可以在服务器组件获取数据时让服务器流式传输 RSC 输出，让浏览器在数据可用时以增量方式呈现数据，并在必要时动态获取客户端组件包。</p>\n<blockquote>\n<p>曾经笔者以为 Suspense 只是和 Loading 组件类似的东西，也是用于数据请求获取中使用，但现在看来似乎不是\n关于 Suspense 的部分，笔者也没了解清楚，想了解更多的可以去看开头推荐的文章</p>\n</blockquote>\n<h2>服务器组件的缺点</h2>\n<ul>\n<li>学习一个新东西总是需要时间，心智负担重</li>\n<li>服务器组件上用不了浏览器相关的 api，甚至没法使用 useState，useEffect 等相关状态的 Hooks</li>\n<li>写 RSC 组件比写单纯的客户端组件复杂不少，需要了解相关的 bundler 以及 framework(NextJs)</li>\n<li>目前来说普及度还不够高，迁移难度高，即使与 RSC 最契合的 NEXTJS，你迁移起来依旧难上加难，更别说原生 React 项目</li>\n</ul>\n","id":"4"},{"title":"DataHub","date":"2023-12-01","categories":"Project","excerpt":"红岩网校数据中台","html":"<h1>数据中台</h1>\n<p>这个项目是用于展示一些产品以及运营的数据，也便于记录运营数据</p>\n<h2>技术栈</h2>\n<ul>\n<li>Vite + React + TS + Arco-design</li>\n<li>Tailwind</li>\n<li>SWR</li>\n<li>recharts</li>\n<li>husky,commitelint,eslint 等等规范配置</li>\n</ul>\n<h2>项目结构</h2>\n<p>总的来说分为可视化图表页以及后台数据页</p>\n<SyntaxHighlighter language=\"shell\" style={oneLight} showLineNumbers>{ `\\├\\─dtable\n\\│  \\├\\─operations\n\\│  \\└\\─product\n\\│      \\├\\─tracking\n\\│      \\└\\─untracking\n\\├\\─dvisualization\n\\└\\─login\n` }</SyntaxHighlighter>\n<p>我负责的就是 dvisualization 部分</p>\n<h2>项目难点以及亮点</h2>\n<h3>侧边栏</h3>\n<p>后台总体框架的搭建和交通局的类似，但是我这次采用了重邮帮后台的路由以及侧边栏渲染，这里就不多谈了，有兴趣可以看<a href=\"https://www.yygod0120.com/2023/10/24/%E2%88%A0%E7%97%9B%E5%B1%80/\">交通局</a></p>\n<h3>数据可视化界面</h3>\n<p>数据可视化界面中的图表，我采用的是<a href=\"https://recharts.org/en-US/\">Rechart</a>,易上手，类型丰富，最重要的是有中文翻译</p>\n<p>因为涉及到数据的展示，所以我采用数据与组件分离的设计模式，将组件和数据抽离开</p>\n<ul>\n<li>service 中获取数据</li>\n<li>Chart 组件中展示数据</li>\n</ul>\n<h4>service</h4>\n<p>先说 service，我们技术选型的时候选择了 SWR 作为网络请求库,原因有以下几点：</p>\n<ol>\n<li>SWR 具有自动重新请求以及用户重新聚集时请求，这有助于数据实时更新以及展示</li>\n<li>SWR 能避免很多 useEffect 中编写网络请求遇到的问题，比如说请求顺序和返回顺序的不一致以及依赖相关的问题。</li>\n<li>完美符合了数据组件分离政策</li>\n<li>相比于 React Query，SWR 更容易上手</li>\n</ol>\n<p>但是 SWR 同样也具有一些缺点</p>\n<SyntaxHighlighter language=\"typescript\" style={oneLight} showLineNumbers>{ `export function useGetPv\\(\\) \\{\n  const \\{ data\\, error\\, isLoading \\} \\= useSWR\\(\n    \\`\\/data\\-middle\\-office\\/pvuv\\?type\\=pv\\&periods\\=\\$\\{xAxis\\[\"days\"\\]\\}\\`\\,\n    fetcher\\,\n  \\)\\;\n  if \\(\\!isLoading \\&\\& \\!error\\) \\{\n    const cqappPv \\= data\\.products\\.cqapp\\;\n    const cqhelperPv \\= data\\.products\\.cqhelper\\;\n    return \\[cqappPv\\, cqhelperPv\\]\\;\n  \\}\n  \\/\\/   return \\[null\\, null\\]\\;\n\\}\n` }</SyntaxHighlighter>\n<p>像这样一个 swr 获取 PV 数据，在 isLoading 阶段是不会有返回值的，这样就会导致<code>const [cqappPv, cqhelperPv] = useGetPv()</code>报错 undefined\n所以我采用<code>return [null,null]</code>来处理,像这样的空值处理在数据组件分离中很常见，感觉我这样的写法也不算是最优的。</p>\n<p>另外一点关于 service 数据处理的是关于类型的处理\n早在<a href=\"https://www.yygod0120.com/2023/09/18/TheFirstRedrockProject/\">暑假的场地申请</a>中遇到两个模块类似的数据的处理，当时我的做法是直接拆开为两个部分，但是这样会有一些问题：</p>\n<ul>\n<li>类型重复度高，无用代码数量多，维护起来困难</li>\n</ul>\n<SyntaxHighlighter language=\"ts\" style={oneLight} showLineNumbers>{ `\\/\\/\\，\\其\\余\\场\\地\nexport interface DataType \\{\n  application_id\\: number\\;\n  location_id\\: number\\;\n  place\\?\\: string\\;\n  apply_date\\: number\\;\n  periods\\?\\: boolean\\[\\]\\;\n  use_date\\?\\: string\\;\n  application\\: string\\;\n  applicant_id\\: string\\;\n  organization\\?\\: string\\;\n  is_org\\: boolean\\;\n  state\\: number\\;\n  reason\\: string\\;\n  phone\\: string\\;\n\\}\n\\/\\/\\科\\技\\会\\堂\nexport interface techologyHallDataType \\{\n  application_id\\: number\\;\n  location_id\\: number\\;\n  place\\?\\: string\\;\n  apply_date\\: number\\;\n  payloads\\: payload\\[\\]\\;\n  periods\\?\\: boolean\\[\\]\\;\n  use_date\\?\\: string\\;\n\n  application\\: string\\;\n  applicant_id\\: string\\;\n  organization_name\\?\\: string\\;\n  is_org\\: boolean\\;\n  state\\: number\\;\n  reason\\: string\\;\n  phone\\: string\\;\n\\}\n` }</SyntaxHighlighter>\n<ul>\n<li>对应模块代码重复度高,cv 过多</li>\n</ul>\n<p>而这次的运营数据也遇到了对应的问题，但这次我选择不分开而是联合起来\n数据类型部分：</p>\n<SyntaxHighlighter language=\"ts\" style={oneLight} showLineNumbers>{ `export type OperationData \\= \\{\n  id\\: string\\;\n  name\\: string\\;\n  periods\\: string\\;\n  purpose\\: string\\;\n  users\\: string\\;\n  price\\: string\\;\n\\}\\;\n\nexport type helperOperationData \\= OperationData \\& \\{\n  reading\\: number\\;\n  transmit\\: number\\;\n\\}\\;\n\nexport type qqOperationData \\= OperationData \\& \\{\n  reading\\: number\\;\n  comment\\: number\\;\n\\}\\;\n\nexport type otherData \\= OperationData \\& \\{\n  way\\: string\\;\n  result\\: string\\;\n\\}\\;\n` }</SyntaxHighlighter>\n<p>获取数据部分：</p>\n<SyntaxHighlighter language=\"ts\" style={oneLight} showLineNumbers>{ `export type Operations\\<T extends \"qq\" \\| \"helper\" \\| \"other\"\\> \\= T extends \"qq\"\n  \\? qqOperationData\\[\\]\n  \\: T extends \"helper\"\n    \\? helperOperationData\\[\\]\n    \\: T extends \"other\"\n      \\? otherData\\[\\]\n      \\: never\\;\nexport function getOperationData\\<T extends \"qq\" \\| \"helper\" \\| \"other\"\\>\\(\n  project\\: T\\,\n  periods\\?\\: string\\,\n\\)\\: Operations\\<T\\> \\| undefined \\{\n  const url \\= periods\n    \\? \\`\\/data\\-middle\\-office\\/runtimes\\/\\$\\{project\\}\\?periods\\=\\$\\{periods\\}\\`\n    \\: \\`\\/data\\-middle\\-office\\/runtimes\\/\\$\\{project\\}\\`\\;\n  \\/\\/ eslint\\-disable\\-next\\-line react\\-hooks\\/rules\\-of\\-hooks\n  const \\{ data\\, error\\, isLoading \\} \\= useSWR\\(url\\, fetcher\\)\\;\n  if \\(isLoading\\) \\{\n    console\\.log\\(\"Loading\\.\\.\\.\"\\)\\;\n    return undefined\\;\n  \\} else if \\(error\\) \\{\n    console\\.log\\(\"Error\\:\"\\, error\\)\\;\n    return undefined\\;\n  \\} else \\{\n    console\\.log\\(\"Data\\:\"\\, data\\)\\;\n    return data as Operations\\<T\\>\\;\n  \\}\n\\}\n` }</SyntaxHighlighter>\n<p>采取对应参数返回对应数据模式，一开始采用的是函数重载方式，但是过于臃肿，于是换成这种泛型模式</p>\n<h4>Charts</h4>\n<p>图表部分我采用的是二层封装的思路</p>\n<ul>\n<li>第一层：对 Rechart 中的折线图，饼图以及柱状图进行封装，让图本身符合要求</li>\n<li>第二层：对封装后的 Rechart 再进行 Header 以及 Bottom 的封装，让图&quot;更完整&quot;</li>\n</ul>\n<p>为了文章的大小就不在这展示了。</p>\n<h2>总结</h2>\n<p>这算是第 4 次做项目，可能也是因为项目本身也不大，做起来还是很快的，只是在后端接口上耽误了时间</p>\n<p>debug 能力也有所提高，对于一些小 bug 比如跨域以及图片路径丢失等等，解决起来比暑假快上不少</p>\n<p>重点收获是图表的封装以及对网络请求的一些理解，还有 React Design 的一些想法</p>\n<blockquote>\n<p>记得关注 RRFE-CLI</p>\n</blockquote>\n","id":"1"},{"title":"React-Design-Patterns","date":"2023-11-18","excerpt":"React 设计模式(译)","categories":"Technology","html":"<p>React 设计模式(译)</p>\n<p><a href=\"https://dev.to/refine/react-design-patterns-230o\">原文链接</a></p>\n<h1>介绍</h1>\n<p>React 开发人员可以通过使用设计模式来节省时间和精力，这些模式提供了一种使用经过测试和信任的解决方案解决问题的快速方法。它们使内聚模块具有较低的耦合性，这反过来又帮助 React 开发人员创建可维护、可扩展和高效的应用程序。在本文中，我们将探讨 React 设计模式，并研究它们如何改进 React 应用程序的开发。</p>\n<h1>容器和表示模式</h1>\n<p>容器和表示模式是一种模式，旨在将表示逻辑与反应代码中的业务逻辑分离，从而使其模块化、可测试，并遵循关注分离原则。\n大多数情况下，在 react 应用程序中，我们需要从后端/存储中获取数据或计算逻辑，并在 react 组件上表示该计算的结果。在这些情况下，容器和表示模式大放异彩，因为它可用于将组件分为两个，即：</p>\n<ul>\n<li>容器组件，充当负责数据提取或计算的组件。</li>\n<li>表示组件，其工作是在 UI（用户界面）上呈现获取的数据或计算值。</li>\n</ul>\n<SyntaxHighlighter language=\"tsx\" style={oneLight} showLineNumbers>{ `\\/\\/Container\\.tsx\nimport React\\, \\{ useEffect \\} from \"react\"\\;\nimport CharacterList from \"\\.\\/CharacterList\"\\;\n\nconst StarWarsCharactersContainer\\: React\\.FC \\= \\(\\) \\=\\> \\{\n  const \\[characters\\, setCharacters\\] \\= useState\\<Character\\>\\(\\[\\]\\)\\;\n  const \\[isLoading\\, setIsLoading\\] \\= useState\\<boolean\\>\\(false\\)\\;\n  const \\[error\\, setError\\] \\= useState\\<boolean\\>\\(false\\)\\;\n\n  const getCharacters \\= async \\(\\) \\=\\> \\{\n    setIsLoading\\(true\\)\\;\n    try \\{\n      const response \\= await fetch\\(\n        \"https\\:\\/\\/akabab\\.github\\.io\\/starwars\\-api\\/api\\/all\\.json\"\\,\n      \\)\\;\n      const data \\= await response\\.json\\(\\)\\;\n      setIsLoading\\(false\\)\\;\n      if \\(\\!data\\) return\\;\n      setCharacters\\(data\\)\\;\n    \\} catch \\(err\\) \\{\n      setError\\(true\\)\\;\n    \\} finally \\{\n      setIsLoading\\(true\\)\\;\n    \\}\n  \\}\\;\n\n  useEffect\\(\\(\\) \\=\\> \\{\n    getCharacters\\(\\)\\;\n  \\}\\, \\[\\]\\)\\;\n\n  return \\(\n    \\<CharacterList loading\\=\\{loading\\} error\\=\\{error\\} characters\\=\\{characters\\} \\/\\>\n  \\)\\;\n\\}\\;\n\nexport default StarWarsCharactersContainer\\;\n` }</SyntaxHighlighter>\n<SyntaxHighlighter language=\"tsx\" style={oneLight} showLineNumbers>{ `\\/\\/the component is responsible for displaying the characters\nimport React from \"react\"\\;\nimport \\{ Character \\} from \"\\.\\/types\"\\;\n\ninterface CharacterListProps \\{\n  loading\\: boolean\\;\n  error\\: boolean\\;\n  users\\: Character\\[\\]\\;\n\\}\n\nconst CharacterList\\: React\\.FC\\<CharacterListProps\\> \\= \\(\\{\n  loading\\,\n  error\\,\n  characters\\,\n\\}\\) \\=\\> \\{\n  if \\(loading \\&\\& \\!error\\) return \\<div\\>Loading\\.\\.\\.\\<\\/div\\>\\;\n  if \\(\\!loading \\&\\& error\\)\n    return \\<div\\>error occured\\.unable to load characters\\<\\/div\\>\\;\n  if \\(\\!characters\\) return null\\;\n\n  return \\(\n    \\<ul\\>\n      \\{characters\\.map\\(\\(user\\) \\=\\> \\(\n        \\<li key\\=\\{user\\.id\\}\\>\\{user\\.name\\}\\<\\/li\\>\n      \\)\\)\\}\n    \\<\\/ul\\>\n  \\)\\;\n\\}\\;\n\nexport default CharacterList\\;\n` }</SyntaxHighlighter>\n<h1>带有 Hooks 的组件组合</h1>\n<p>钩子是 React 16.8 中首次亮相的全新功能。从那时起，他们在开发 react 应用程序方面发挥了至关重要的作用。钩子是基本函数，用于授予功能组件对状态和生命周期方法的访问权限（以前仅供类组件使用）。另一方面，钩子可以专门设计来满足组件要求并具有其他用例。\n现在，我们可以隔离所有有状态逻辑（一种需要反应式状态变量的逻辑），并使用自定义钩子在组件中编写或使用它。因此，代码更加模块化和可测试，因为钩子松散地绑定在组件上，因此可以单独测试。\n下面显示了带有钩子的组件组合示例：</p>\n<SyntaxHighlighter language=\"tsx\" style={oneLight} showLineNumbers>{ `\\/\\/ creating a custom hook that fetches star wars characters\nexport const useFetchStarWarsCharacters \\= \\(\\) \\=\\> \\{\n  const \\[characters\\, setCharacters\\] \\= useState\\<Character\\>\\(\\[\\]\\)\\;\n  const \\[isLoading\\, setIsLoading\\] \\= useState\\(false\\)\\;\n  const \\[error\\, setError\\] \\= useState\\(false\\)\\;\n  const controller \\= new AbortController\\(\\)\\;\n\n  const getCharacters \\= async \\(\\) \\=\\> \\{\n    setIsLoading\\(true\\)\\;\n    try \\{\n      const response \\= await fetch\\(\n        \"https\\:\\/\\/akabab\\.github\\.io\\/starwars\\-api\\/api\\/all\\.json\"\\,\n        \\{\n          method\\: \"GET\"\\,\n          credentials\\: \"include\"\\,\n          mode\\: \"cors\"\\,\n          headers\\: \\{\n            \"Content\\-Type\"\\: \"application\\/json\"\\,\n            \"Access\\-Control\\-Allow\\-Origin\"\\: \"\\*\"\\,\n          \\}\\,\n          signal\\: controller\\.signal\\,\n        \\}\\,\n      \\)\\;\n      const data \\= await response\\.json\\(\\)\\;\n      setIsLoading\\(false\\)\\;\n      if \\(\\!data\\) return\\;\n      setCharacters\\(data\\)\\;\n    \\} catch \\(err\\) \\{\n      setError\\(true\\)\\;\n    \\} finally \\{\n      setIsLoading\\(true\\)\\;\n    \\}\n  \\}\\;\n\n  useEffect\\(\\(\\) \\=\\> \\{\n    getCharacters\\(\\)\\;\n    return \\(\\) \\=\\> \\{\n      controller\\.abort\\(\\)\\;\n    \\}\\;\n  \\}\\, \\[\\]\\)\\;\n\n  return \\[characters\\, isLoading\\, error\\]\\;\n\\}\\;\n` }</SyntaxHighlighter>\n<p>创建自定义钩子后，我们会将其导入到我们的 StarWarsCharactersContainer 组件中并使用它:</p>\n<SyntaxHighlighter language=\"tsx\" style={oneLight} showLineNumbers>{ `\\/\\/ importing the custom hook to a component and fetch the characters\n\nimport React from \"react\"\\;\nimport \\{ Character \\} from \"\\.\\/types\"\\;\nimport \\{ useFetchStarWarsCharacters \\} from \"\\.\\/useFetchStarWarsCharacters\"\\;\n\nconst StarWarsCharactersContainer\\: React\\.FC \\= \\(\\) \\=\\> \\{\n  const \\[characters\\, isLoading\\, error\\] \\= useFetchStarWarsCharacters\\(\\)\\;\n\n  return \\(\n    \\<CharacterList loading\\=\\{loading\\} error\\=\\{error\\} characters\\=\\{characters\\} \\/\\>\n  \\)\\;\n\\}\\;\n\nexport default StarWarsCharactersContainer\\;\n` }</SyntaxHighlighter>\n<h1>使用 Reducers 进行状态管理</h1>\n<p>大多数情况下，处理组件中的许多状态会导致许多未分组状态的问题，这可能很麻烦且难以处理。在这种情况下，Reducers 模式可能是一个有用的选择。我们可以使用 reducer 将状态分类为某些操作，这些操作在执行时可以更改分组状态。\n此模式允许使用它的开发人员控制组件和/或钩子的状态管理，让他们在发送事件时管理状态更改。\n使用 Reducer 模式的示例如下所示：</p>\n<SyntaxHighlighter language=\"tsx\" style={oneLight} showLineNumbers>{ `import \\{React\\, i useReducer \\} from 'react'\\;\nconst initstate \\= \\{\n    loggedIn\\: false\\,user\\: null\\,\n    token\\: nuli\n\\}\nfunction authReducer\\(state\\,action\\) \\{\n    switch \\(action\\.type\\) \\{\n        case 'login'\\:\n            return \\{\n                loggedIn\\: true\\,\n                user\\: action\\. payload\\.user\\,token\\: action\\. payload\\.token\n                \\}\n        case 'logout'\\:\n            return initState\\;\n        default\\:\n            break\\;\n    \\}\n\\}\nconst AuthComponent \\=\\(\\)\\=\\> \\{\n    const \\[state\\, dispatch\\] \\= useReducer\\(authReducer\\， initstate\\)\\;\n    const logIn \\=\\(\\)\\=\\>\\{\n        dispatch\\(\\{type\\:'login'\\,payload\\:\\{\n            user\\:\\{name\\:'John Doe'\\}\\,\n            token\\:'token'\n        \\}\\}\\)\\;\n    \\}\n    const logout \\= \\(\\)\\=\\> \\{\n        dispatch\\(\\{ type\\: 'logout' \\}\\)\\;\n    \\}\nreturn \\(\n    \\<div\\>\n    \\{ state\\.loggedIn \\? \\(\n        \\<div\\>\n            \\<p\\> Welcome \\{ state\\.user\\.name \\}\\<\\/ p\\>\\<button onclick\\=\\{logout\\}\\>\\<\\/ button\\>\n        \\<\\/div\\>\n    \\)\\:\\(\n    \\<form onSubmit\\=\\{logIn\\}\\>\n        \\<input type\\=\"text\"\\/\\>\n        \\<input type\\=\"password\"\\/\\>\n        \\<button type\\=\"submit\"\\>\\<\\/button\\>\n    \\<\\/form\\>\n    \\)\n    \\}\n    \\<\\/div\\>\n\\)\n\\}\n` }</SyntaxHighlighter>\n<p>在上面的代码中，该组件调度了两个操作：</p>\n<ul>\n<li>“login”操作类型会触发状态更改，该更改会影响三个状态值，即 loggedIn、user、token。</li>\n<li>“注销”操作只是将状态重置为其初始值。</li>\n</ul>\n<h1>使用提供程序进行数据管理</h1>\n<p>提供程序模式对于数据管理非常有用，因为它利用上下文 API 通过应用程序的组件树传递数据。这种模式是 Props drilling 的有效解决方案，Props drilling 一直是 React 开发中常见的问题。\n为了实现提供程序模式，我们将首先创建一个提供程序组件。提供程序是 Context 对象提供给我们的高阶组件。我们可以利用 React 提供的 createContext 方法构造一个 Context 对象。</p>\n<SyntaxHighlighter language=\"tsx\" style={oneLight} showLineNumbers>{ `export const ThemeContext \\= React\\.createContext\\(null\\)\\;\n\nexport function ThemeProvider\\(\\{ children \\}\\) \\{\n  const \\[theme\\, setTheme\\] \\= React\\.useState\\(\"light\"\\)\\;\n\n  return \\(\n    \\<ThemeContext\\.Provider value\\=\\{\\{ theme\\, setTheme \\}\\}\\>\n      \\{children\\}\n    \\<\\/ThemeContext\\.Provider\\>\n  \\)\\;\n\\}\n` }</SyntaxHighlighter>\n<p>创建提供程序后，我们将使用创建的提供程序组件将依赖于上下文 API 中数据的组件封闭起来。\n为了从上下文 API 获取数据，我们调用 useContext 钩子，它接受上下文作为参数（在本例中为 ThemeContext）。</p>\n<SyntaxHighlighter language=\"tsx\" style={oneLight} showLineNumbers>{ `import \\{ useContext \\} from \"react\"\\;\nimport \\{ ThemeProvider\\, ThemeContext \\} from \"\\.\\.\\/context\"\\;\n\nconst HeaderSection \\= \\(\\) \\=\\> \\{\n  \\<ThemeProvider\\>\n    \\<TopNav \\/\\>\n  \\<\\/ThemeProvider\\>\\;\n\\}\\;\n\nconst TopNav \\= \\(\\) \\=\\> \\{\n  const \\{ theme\\, setTheme \\} \\= useContext\\(ThemeContext\\)\\;\n\n  return \\(\n    \\<div style\\=\\{\\{ backgroundColor\\: theme \\=\\=\\= \"light\" \\? \"\\#fff\" \\: \"\\#000 \" \\}\\}\\>\n      \\.\\.\\.\n    \\<\\/div\\>\n  \\)\\;\n\\}\\;\n` }</SyntaxHighlighter>\n<h1>使用 HOC（高阶组件）增强组件</h1>\n<p>高阶组件将组件作为参数，并返回注入了附加数据或功能的增压组件。React 中 HOC 的可能性是由于 React 对组合的偏好而不是继承。\n高阶组件 （HOC） 模式提供了一种增加或修改组件功能的机制，从而促进了组件重用和代码共享。\nHOC 模式的示例如下所示：</p>\n<SyntaxHighlighter language=\"tsx\" style={oneLight} showLineNumbers>{ `import React from 'react'\n\nconst higherOrderComponent \\= Component \\=\\> \\{\n  return class HOC extends React\\.Component \\{\n    state \\= \\{\n      name\\: 'John Doe'\n    \\}\n\n    render\\(\\) \\{\n      return \\<Component name\\=\\{this\\.state\\.name \\{\\.\\.\\.this\\.props\\}\\} \\/\\>\n    \\}\n \\}\\}\n\n\nconst AvatarComponent \\= \\(props\\) \\=\\> \\{\n  return \\(\n    \\<div className\\=\"flex items\\-center justify\\-between\"\\>\n      \\<div className\\=\"rounded\\-full bg\\-red p\\-4\"\\>\n          \\{props\\.name\\}\n      \\<\\/div\\>\n      \\<div\\>\n          \\<p\\>I am a \\{props\\.description\\}\\.\\<\\/p\\>\n      \\<\\/div\\>\n    \\<\\/div\\>\n  \\)\n\\}\n\n\nconst SampleHOC \\= higherOrderComponent\\(AvatarComponent\\)\\;\n\n\nconst App \\= \\(\\) \\=\\> \\{\n  return \\(\n    \\<div\\>\n      \\<SampleHOC description\\=\"Frontend Engineer\" \\/\\>\n    \\<\\/div\\>\n  \\)\n\\}\n\nexport default App\\;\n` }</SyntaxHighlighter>\n<p>在上面的代码中，由 higherOrderComponent 提供 props，它将在内部使用。</p>\n<h1>复合组件</h1>\n<p>复合组件模式是一种 React 设计模式，用于管理由子组件组成的父组件。\n这种模式背后的原理是将父组件分解为更小的组件，然后使用道具、上下文或其他 React 数据管理技术来管理这些较小组件之间的交互。\n当需要创建由较小组件组成的可重用的多功能组件时，此模式会派上用场。它使开发人员能够创建复杂的 UI 组件，这些组件可以轻松自定义和扩展，同时保持清晰简单的代码结构。\n复合组件模式的用例示例如下所示：</p>\n<SyntaxHighlighter language=\"tsx\" style={oneLight} showLineNumbers>{ `import React\\, \\{ createContext\\, useState \\} from \"react\"\\;\n\nconst ToggleContext \\= createContext\\(\\)\\;\n\nfunction Toggle\\(\\{ children \\}\\) \\{\n  const \\[on\\, setOn\\] \\= useState\\(false\\)\\;\n  const toggle \\= \\(\\) \\=\\> setOn\\(\\!on\\)\\;\n\n  return \\(\n    \\<ToggleContext\\.Provider value\\=\\{\\{ on\\, toggle \\}\\}\\>\n      \\{children\\}\n    \\<\\/ToggleContext\\.Provider\\>\n  \\)\\;\n\\}\n\nToggle\\.On \\= function ToggleOn\\(\\{ children \\}\\) \\{\n  const \\{ on \\} \\= useContext\\(ToggleContext\\)\\;\n  return on \\? children \\: null\\;\n\\}\\;\n\nToggle\\.Off \\= function ToggleOff\\(\\{ children \\}\\) \\{\n  const \\{ on \\} \\= useContext\\(ToggleContext\\)\\;\n  return on \\? null \\: children\\;\n\\}\\;\n\nToggle\\.Button \\= function ToggleButton\\(props\\) \\{\n  const \\{ on\\, toggle \\} \\= useContext\\(ToggleContext\\)\\;\n  return \\<button onClick\\=\\{toggle\\} \\{\\.\\.\\.props\\} \\/\\>\\;\n\\}\\;\n\nfunction App\\(\\) \\{\n  return \\(\n    \\<Toggle\\>\n      \\<Toggle\\.On\\>The button is on\\<\\/Toggle\\.On\\>\n      \\<Toggle\\.Off\\>The button is off\\<\\/Toggle\\.Off\\>\n      \\<Toggle\\.Button\\>Toggle\\<\\/Toggle\\.Button\\>\n    \\<\\/Toggle\\>\n  \\)\\;\n\\}\n` }</SyntaxHighlighter>\n<h1>Prop 组合</h1>\n<p>这需要从几个相关的 prop 中创建一个对象，并将其作为单个 prop 传递给组件。\n这种模式允许我们清理代码并简化道具的管理，这在我们想要将大量相关属性传递给组件时特别有用。</p>\n<SyntaxHighlighter language=\"tsx\" style={oneLight} showLineNumbers>{ `import React from \"react\"\\;\n\nfunction P\\(props\\) \\{\n  const \\{ color\\, size\\, children\\, \\.\\.\\.rest \\} \\= props\\;\n  return \\(\n    \\<p style\\=\\{\\{ color\\, fontSize\\: size \\}\\} \\{\\.\\.\\.rest\\}\\>\n      \\{children\\}\n    \\<\\/p\\>\n  \\)\\;\n\\}\n\nfunction App\\(\\) \\{\n  const paragraphProps \\= \\{\n    color\\: \"red\"\\,\n    size\\: \"20px\"\\,\n    lineHeight\\: \"22px\"\\,\n  \\}\\;\n  return \\<P \\{\\.\\.\\.paragraphProps\\}\\>This is a P\\<\\/P\\>\\;\n\\}\n` }</SyntaxHighlighter>\n<h1>受控输入</h1>\n<p>受控输入模式可用于处理输入字段。此模式涉及使用事件处理程序在输入字段的值发生更改时更新组件状态，以及将输入字段的当前值存储在组件状态中。\n由于 React 控制组件的状态和行为，因此这种模式使代码比不受控制的输入模式更具可预测性和可读性，后者不使用组件的状态，而是直接通过 DOM（文档对象模型）来控制它。\n受控输入模式的用例示例如下所示：</p>\n<SyntaxHighlighter language=\"tsx\" style={oneLight} showLineNumbers>{ `import React\\, \\{ useState \\} from \"react\"\\;\n\nfunction ControlledInput\\(\\) \\{\n  const \\[inputValue\\, setInputValue\\] \\= useState\\(\"\"\\)\\;\n\n  const handleChange \\= \\(event\\) \\=\\> \\{\n    setInputValue\\(event\\.target\\.value\\)\\;\n  \\}\\;\n\n  return \\<input type\\=\"text\" value\\=\\{inputValue\\} onChange\\=\\{handleChange\\} \\/\\>\\;\n\\}\n` }</SyntaxHighlighter>\n<h1>使用 fowardRefs 管理自定义组件</h1>\n<p>称为 ForwardRef 的高阶组件将另一个组件作为输入，并输出一个传递原始组件的 ref 的新组件。通过这样做，子组件的 ref（可用于检索底层 DOM 节点或组件实例）可供父组件访问。\n创建与第三方库或应用程序中的其他自定义组件交互的自定义组件时，在工作流中包含 ForwardRef 模式非常有帮助。通过授予对库的 DOM 节点或其他组件的 DOM 实例的访问权限，它有助于将此类组件的控制权转移给您。\n下面显示了 forwardRef 模式的用例示例：</p>\n<SyntaxHighlighter language=\"tsx\" style={oneLight} showLineNumbers>{ `import React from \"react\"\\;\n\nconst CustomInput \\= React\\.forwardRef\\(\\(props\\, ref\\) \\=\\> \\(\n  \\<input type\\=\"text\" \\{\\.\\.\\.props\\} ref\\=\\{ref\\} \\/\\>\n\\)\\)\\;\n\nconst ParentComponent \\= \\(\\) \\=\\> \\{\n  const inputRef \\= useRef\\(null\\)\\;\n\n  useEffect\\(\\(\\) \\=\\> \\{\n    inputRef\\.current\\.focus\\(\\)\\;\n  \\}\\, \\[\\]\\)\\;\n\n  return \\<CustomInput ref\\=\\{inputRef\\} \\/\\>\\;\n\\}\\;\n` }</SyntaxHighlighter>\n<p>在上面的代码中，我们 <code>&lt;CustomInput/&gt;</code> <code>&lt;ParentComponent/&gt;</code> 使用 forwardRefs .</p>\n<h1>总结</h1>\n<p>我们在本文中讨论了 React 设计模式，包括高阶组件、容器表示组件模式、复合组件、受控组件等等。通过将这些设计模式和最佳实践整合到您的 React 项目中，您可以提高代码质量、促进团队协作，并使您的应用程序更具可扩展性、灵活性和可维护性。</p>\n","id":"3"},{"title":"交通局","date":"2023-10-24","categories":"Project","excerpt":"丰都县交通局,一个缝合了12306，嘀嘀打车，货拉拉的网页应用你敢相信。","html":"<h1>丰都县交通局</h1>\n<blockquote>\n<p>记得下次好好评审项目以及拉黑胡*</p>\n</blockquote>\n<p><a href=\"http://47.108.56.37:8080/\">项目地址</a>\n市民端：账 123456 密 123456</p>\n<h2>项目概述</h2>\n<p>一个基本的后台管理，但是内容极其恶心，既要打车又要货拉拉还要 12306 买票</p>\n<p>最恶心的就是没有正规的 12306，都是自己爬的接口用。<del>不会被抓吧</del></p>\n<h2>技术栈</h2>\n<ol>\n<li>React + Vite + arcodesign</li>\n<li>tailwind</li>\n<li>recoil</li>\n<li>moment</li>\n</ol>\n<p>属于是只用上了基本的东西</p>\n<h2>负责模块</h2>\n<ol>\n<li>布局以及侧边栏</li>\n<li>信息栏的用户端以及管理端</li>\n<li>权限管理端</li>\n</ol>\n<h3>侧边栏</h3>\n<p>这个项目采用的是文件路由的方式，类似于 Next.js 的文件路由\n所以通过将文件也就是路由扁平化，递归判断是否为父文件还是子文件来进行侧边栏渲染\n通过权限判断一些选项是否渲染，从而达到隐藏的作用</p>\n<SyntaxHighlighter language=\"js\" style={oneLight} showLineNumbers>{ `\\/\\/\\文\\件\\路\\由\\实\\现\nconst layout\\: Record\\<string\\, FC\\<any\\> \\| null\\> \\= \\{\n  default\\: \\(props\\) \\=\\> \\(\n    \\<Layout\\>\n      \\<\\>\\{props\\.children\\}\\<\\/\\>\n    \\<\\/Layout\\>\n  \\)\\,\n  login\\: \\(props\\) \\=\\> \\<\\>\\{props\\.children\\}\\<\\/\\>\\,\n  systemManage\\: \\(props\\) \\=\\> \\(\n    \\<Layout\\>\n      \\<SystemLayout\\>\\{props\\.children\\}\\<\\/SystemLayout\\>\n    \\<\\/Layout\\>\n  \\)\\,\n  companyManage\\: \\(props\\) \\=\\> \\(\n    \\<Layout\\>\n      \\<CompanyLayout\\>\\{props\\.children\\}\\<\\/CompanyLayout\\>\n    \\<\\/Layout\\>\n  \\)\\,\n\\}\\;\nlayout\\;\nconst routeModule\\: Record\\<number\\, \\(\\) \\=\\> JSX\\.Element\\> \\= import\\.meta\\.glob\\(\n  \"\\.\\/routes\\/\\*\\*\\/\\*\\.tsx\"\\,\n  \\{\n    eager\\: true\\,\n    import\\: \"default\"\\,\n  \\}\\,\n\\)\\;\nconst modules \\= Object\\.entries\\(routeModule\\)\\;\nconst pathRegExp \\= \\/\\\\\\.\\\\\\/routes\\(\\.\\*\\)\\.tsx\\/\\;\nconst defaultRoutes\\: RouteObject\\[\\] \\= modules\n  \\.filter\\(\\(\\[path\\]\\) \\=\\> \\!path\\.includes\\(\"children\"\\)\\)\n  \\.map\\(\\(v\\) \\=\\> \\{\n    const \\[path\\, Element\\] \\= v\\;\n    const pathLike \\= path\\.replace\\(pathRegExp\\, \"\\$1\"\\)\\;\n    let routePath \\= \\/\\\\\\/index\\/\\.test\\(pathLike\\)\n      \\? pathLike\\.replace\\(\\/\\\\\\/index\\/\\, \"\"\\)\n      \\: pathLike\\;\n    if \\(\\/\\\\\\[\\\\w\\+\\\\\\]\\/\\.test\\(pathLike\\)\\) \\{\n      const slug \\= pathLike\\.replace\\(\\/\\.\\*\\\\\\[\\(\\\\w\\+\\)\\\\\\]\\/\\, \"\\$1\"\\)\\;\n      routePath \\= pathLike\\.replace\\(\\/\\\\\\[\\\\w\\+\\\\\\]\\/\\, \\`\\:\\$\\{slug\\}\\`\\)\\;\n    \\}\n    \\/\\/ console\\.log\\(path\\.split\\(\"\\/\"\\)\\.filter\\(Boolean\\)\\)\\;\n    const \\[\\, \\, login\\, key\\] \\= path\\.split\\(\"\\/\"\\)\\.filter\\(Boolean\\)\\;\n    let Layout \\= layout\\[key\\]\\;\n    Layout \\?\\?\\= layout\\[\"default\"\\]\\;\n    \\/\\/ console\\.log\\(login\\)\\;\n    if \\(login \\=\\=\\= \"login\"\\) \\{\n      Layout \\= layout\\[\"login\"\\]\\;\n    \\}\n    const route\\: RouteObject \\= \\{\n      path\\: routePath\\,\n      element\\: Layout \\? \\(\n        \\<Layout\\>\n          \\<Element \\/\\>\n        \\<\\/Layout\\>\n      \\) \\: \\(\n        \\<Element \\/\\>\n      \\)\\,\n      errorElement\\: \\<NotFoundPage \\/\\>\\,\n    \\}\\;\n    return route\\;\n  \\}\\)\\;\nconst childrenRoutes \\= createChildren\\(routeModule\\)\\;\nconst \\{ children \\= \\[\\] \\} \\= childrenToArray\\(childrenRoutes\\)\\;\ndefaultRoutes\\.forEach\\(\\(v1\\) \\=\\> \\{\n  children\\.forEach\\(\\(v2\\) \\=\\> \\{\n    if \\(v1\\.path\\?\\.endsWith\\(v2\\.path\\!\\)\\) v1\\.children \\= v2\\.children\\;\n  \\}\\)\\;\n\\}\\)\\;\nexport const routes\\: RouteObject\\[\\] \\= \\[\\.\\.\\.defaultRoutes\\]\\;\nexport const router \\= createHashRouter\\(routes\\)\\;\n` }</SyntaxHighlighter>\n<SyntaxHighlighter language=\"js\" style={oneLight} showLineNumbers>{ `\\/\\/\\/\\侧\\边\\栏\\渲\\染\nexport default function Side\\(\\) \\{\n  const \\[selectKey\\, setSelectKey\\] \\= useState\\<string\\[\\]\\>\\(\\[\\]\\)\n  function renderMenu\\(\n    routes\\: IRoutes\\[\\]\\,\n    menu\\: MenuType\\,\n    routerFather\\: string\\,\n    isFirstSubmenu\\: boolean\\,\n  \\) \\{\n    return routes\\.map\\(\\(route\\) \\=\\> \\{\n      const key \\= routerFather\n        \\? \\`\\$\\{routerFather\\}\\.\\$\\{route\\.RouterFather\\}\\`\n        \\: \\`menu\\.\\$\\{route\\.RouterFather\\}\\`\\;\n      const path \\= key\n        \\.replace\\(\\/\\^menu\\\\\\.\\/\\, \"\"\\)\n        \\.split\\(\"\\.\"\\)\n        \\.join\\(\"\\/\"\\)\\;\n      if \\(route\\.RoutesChildren\\.length \\> 0\\) \\{\n        \\/\\/ console\\.log\\(route\\.RouterFather\\!\\)\\;\n        return \\(\n          \\<SubMenu\n            style\\=\\{showSystem\\(localStorage\\.getItem\\('role'\\)\\!\\)\\.includes\\(key\\) \\? undefined \\: \\{ display\\: 'none' \\}\\}\n            key\\=\\{key\\}\n            title\\=\\{\n              isFirstSubmenu \\? \\(\n                \\<div className\\=\" flex items\\-center\"\\>\n                  \\<div className\\=\" w\\-3 h\\-3 bg\\-circle rounded\\-full mr\\-4\"\\>\\<\\/div\\>\n                  \\<div className\\=\" \"\\>\\{menu\\[key\\]\\}\\<\\/div\\>\n                \\<\\/div\\>\n              \\) \\: \\(\n                menu\\[key\\]\n              \\)\n            \\}\n          \\>\n            \\{renderMenu\\(route\\.RoutesChildren as IRoutes\\[\\]\\, menu\\, key\\, false\\)\\}\n          \\<\\/SubMenu\\>\n        \\)\\;\n      \\} else \\{\n        return \\(\n          \\<Menu\\.Item key\\=\\{key\\} style\\=\\{showSystem\\(localStorage\\.getItem\\('role'\\)\\!\\)\\.includes\\(key\\) \\? undefined \\: \\{ display\\: 'none' \\}\\} onClick\\=\\{\\(\\) \\=\\> \\{\n            setSelectKey\\(\\[key\\]\\)\n          \\}\\}\\>\n            \\<Link to\\=\\{\"\\/\" \\+ path\\} style\\=\\{\\{ color\\: \"\\#424B5E99\" \\}\\}\\>\n              \\{menu\\[key\\]\\}\n            \\<\\/Link\\>\n          \\<\\/Menu\\.Item\\>\n        \\)\\;\n      \\}\n    \\}\\)\\;\n  \\}\n  const Routes \\= splitRoutes\\(menu\\)\\;\n  const url \\= useLocation\\(\\)\\;\n  \\/\\/ if\\(url\\.pathname\\.startsWith\\('\\/reservation\\/user'\\)\\)\\{\n  \\/\\/   const key \\= \\['menu\\.reservation\\.'\\]\n  \\/\\/ \\}\n\n\n  return \\(\n    \\<div className\\=\"text\\-white overflow\\-hidden overflow\\-y\\-scroll hide\\-scrollbar h\\-\\[92vh\\]\"\\>\n      \\<Menu\n        className\\=\"\"\n        levelIndent\\=\\{30\\}\n        selectedKeys\\=\\{selectKey\\}\n        defaultOpenKeys\\=\\{url\\.pathname\\.split\\('\\/'\\)\\}\n      \\>\n        \\{renderMenu\\(Routes\\, menu\\, \"\"\\, true\\)\\}\n      \\<\\/Menu\\>\n    \\<\\/div\\>\n  \\)\\;\n\\}\n` }</SyntaxHighlighter>\n<p>优点：</p>\n<ol>\n<li>方便，不需要编写路由表，只需要创建文件就会自动生成对应路由。</li>\n<li>后期渲染侧边栏的 menu 文件相比路由表配置起来也简单</li>\n</ol>\n<p>缺点：</p>\n<ol>\n<li>文件一创建就会生成路由，先前通过文件渲染侧边栏就会导致不想渲染的子路由也出现在侧边栏。\n解决方案是通过 menu 配置进行筛选渲染，但是如此一来就和配置路由表大差不差。</li>\n</ol>\n<p>总结就是：想使用文件路由，可以直接上手<code>Next.js</code>，能方便很多。加上设置侧边栏也是通过<code>menu.ts</code>来进行配置,倒不如直接使用路由表来渲染</p>\n<p>例子：</p>\n<SyntaxHighlighter language=\"ts\" style={oneLight} showLineNumbers>{ `\\/\\/\\路\\由\\类\\型\ntype Auth \\= \\{\n  resource\\: string \\| RegExp\\;\n  actions\\?\\: string\\[\\]\\;\n\\}\\;\nexport interface AuthParams \\{\n  \\/\\/ \\某\\操\\作\\需\\要\\的\\权\\限\\数\\组\n  requiredPermissions\\?\\: Array\\<Auth\\>\\;\n  \\/\\/ \\是\\否\\需\\要\\满\\足\\一\\个\\即\\可\\，\\即\\是\\或\\还\\是\\且\\。\n  oneOfPerm\\?\\: boolean\\;\n\\}\nexport type IRoute \\= AuthParams \\& \\{\n  name\\: string\\;\n  key\\: string\\;\n  breadcrumb\\?\\: boolean\\;\n  children\\?\\: IRoute\\[\\]\\;\n  hideInMenu\\?\\: boolean\\; \\/\\/ \\是\\否\\在\\菜\\单\\中\\隐\\藏\\子\\路\\由\\，\\为\\了\\实\\现\\某\\些\\三\\级\\路\\由\\不\\展\\示\\在\\菜\\单\\中\\的\\需\\求\n  icon\\?\\: React\\.ForwardRefExoticComponent\\<\n    IconProps \\& React\\.RefAttributes\\<unknown\\>\n  \\>\\;\n\\}\\;\n` }</SyntaxHighlighter>\n<SyntaxHighlighter language=\"tsx\" style={oneLight} showLineNumbers>{ `export const generatePermission \\= \\(level\\: string\\) \\=\\> \\{\n  const actions \\= level \\=\\=\\= \"3\" \\? \\[\\] \\: \\[\"\\*\"\\]\\;\n  const result \\= \\{\\}\\;\n  routes\\.forEach\\(\\(item\\) \\=\\> \\{\n    if \\(item\\.children\\) \\{\n      item\\.children\\.forEach\\(\\(child\\) \\=\\> \\{\n        result\\[child\\.name\\] \\= actions\\;\n      \\}\\)\\;\n    \\}\n  \\}\\)\\;\n  return result\\;\n\\}\\;\nconst useRoute \\= \\(userPermission\\)\\: \\[IRoute\\[\\]\\, string\\] \\=\\> \\{\n  const filterRoute \\= \\(routes\\: IRoute\\[\\]\\, arr \\= \\[\\]\\)\\: IRoute\\[\\] \\=\\> \\{\n    if \\(\\!routes\\.length\\) \\{\n      return \\[\\]\\;\n    \\}\n    for \\(const route of routes\\) \\{\n      const \\{ requiredPermissions\\, oneOfPerm \\} \\= route\\;\n      let visible \\= true\\;\n      if \\(requiredPermissions\\) \\{\n        visible \\= auth\\(\\{ requiredPermissions\\, oneOfPerm \\}\\, userPermission\\)\\;\n      \\}\n      if \\(\\!visible\\) \\{\n        continue\\;\n      \\}\n      if \\(route\\.children \\&\\& route\\.children\\.length\\) \\{\n        const newRoute \\= \\{ \\.\\.\\.route\\, children\\: \\[\\] \\}\\;\n        filterRoute\\(route\\.children\\, newRoute\\.children\\)\\;\n        if \\(newRoute\\.children\\.length\\) \\{\n          arr\\.push\\(newRoute\\)\\;\n        \\}\n      \\} else \\{\n        arr\\.push\\(\\{ \\.\\.\\.route \\}\\)\\;\n      \\}\n    \\}\n\n    return arr\\;\n  \\}\\;\n  const \\[permissionRoute\\, setPermissionRoute\\] \\= useState\\(routes\\)\\;\n  useEffect\\(\\(\\) \\=\\> \\{\n    const newRoutes \\= filterRoute\\(routes\\)\\;\n    setPermissionRoute\\(newRoutes\\)\\;\n    \\/\\/ eslint\\-disable\\-next\\-line react\\-hooks\\/exhaustive\\-deps\n  \\}\\, \\[userPermission\\]\\)\\;\n\n  const defaultRoute \\= useMemo\\(\\(\\) \\=\\> \\{\n    const first \\= permissionRoute\\[0\\]\\;\n    if \\(first\\) \\{\n      const firstRoute \\= first\\?\\.children\\?\\.\\[0\\]\\?\\.key \\|\\| first\\.key\\;\n      return firstRoute\\;\n    \\}\n    return \"\"\\;\n  \\}\\, \\[permissionRoute\\]\\)\\;\n\n  return \\[permissionRoute\\, defaultRoute\\]\\;\n\\}\\;\n\nexport default useRoute\\;\n` }</SyntaxHighlighter>\n<SyntaxHighlighter language=\"tsx\" style={oneLight} showLineNumbers>{ `\\/\\/\\渲\\染\nfunction renderRoutes\\(locale\\: \\{ \\[x\\: string\\]\\: any \\}\\) \\{\n  routeMap\\.current\\.clear\\(\\)\\;\n  return function travel\\(_routes\\: IRoute\\[\\]\\, level\\: number\\, parentNode \\= \\[\\]\\) \\{\n    return _routes\\.map\\(\\(route\\) \\=\\> \\{\n      const \\{ breadcrumb \\= true\\, hideInMenu \\} \\= route\\;\n      const iconDom \\= getIcon\\(route\\)\\;\n      const titleDom \\= \\(\n        \\<\\>\n          \\{iconDom\\} \\{locale\\[route\\.name\\] \\|\\| route\\.name\\}\n        \\<\\/\\>\n      \\)\\;\n      routeMap\\.current\\.set\\(\n        \\`\\/\\$\\{route\\.key\\}\\`\\,\n        breadcrumb \\? \\[\\.\\.\\.parentNode\\, route\\.name\\] \\: \\[\\]\\,\n      \\)\\;\n      const visibleChildren \\= \\(route\\.children \\|\\| \\[\\]\\)\\.filter\\(\\(child\\) \\=\\> \\{\n        const \\{ hideInMenu\\, breadcrumb \\= true \\} \\= child\\;\n        if \\(hideInMenu \\|\\| route\\.hideInMenu\\) \\{\n          routeMap\\.current\\.set\\(\n            \\`\\/\\$\\{child\\.key\\}\\`\\,\n            breadcrumb \\? \\[\\.\\.\\.parentNode\\, route\\.name\\, child\\.name\\] \\: \\[\\]\\,\n          \\)\\;\n        \\}\n        return \\!hideInMenu\\;\n      \\}\\)\\;\n      \\/\\/ console\\.log\\(visibleChildren\\)\\;\n      if \\(hideInMenu\\) \\{\n        return \\[\\]\\;\n      \\}\n      if \\(visibleChildren\\.length\\) \\{\n        return \\(\n          \\<SubMenu key\\=\\{route\\.key\\} title\\=\\{titleDom\\}\\>\n            \\{travel\\(visibleChildren\\, level \\+ 1\\, \\[\\.\\.\\.parentNode\\, route\\.name\\]\\)\\}\n          \\<\\/SubMenu\\>\n        \\)\\;\n      \\}\n      return \\(\n        \\<MenuItem key\\=\\{route\\.key\\}\\>\n          \\<Link to\\=\\{\\`\\/\\$\\{route\\.key\\}\\`\\}\\>\\{titleDom\\}\\<\\/Link\\>\n        \\<\\/MenuItem\\>\n      \\)\\;\n    \\}\\)\\;\n  \\}\\;\n\\}\n` }</SyntaxHighlighter>\n<p>通过配置路由，可以分权配置，细分到页面和操作，适用于大型的后台管理</p>\n<p>直接通过文件配置路由，适用于简单的后台，不需要配置路由表的情况下，用起来方便\n当然你可以自己选择 Next.js</p>\n<p><del>鄙人浅显的见解，大佬轻喷</del></p>\n<h3>剩下两个模块</h3>\n<p>简单的表格组件使用而已，没什么亮点</p>\n<h2>收获</h2>\n<p>对这种路由布局理解提高了一点\n帮他们写 12306 的时候，学会了抓包工具 Fiddler Classic。<del>说不定哪天能写一个有趣的东西</del></p>\n","id":"14"},{"title":"长沙之旅","date":"2023-10-03","categories":"Life","excerpt":"独立寒秋，湘江北去，橘子洲头。看万山红遍，层林尽染；漫江碧透，百舸争流。鹰击长空，鱼翔浅底，万类霜天竞自由。怅寥廓，问苍茫大地，谁主沉浮？携来百侣曾游。忆往昔峥嵘岁月稠。恰同学少年，风华正茂书生意气，挥斥方遒。指点江山，激扬文字，粪土当年万户侯。曾记否，到中流击水，浪遏飞舟？","html":"<blockquote>\n<p>下次记得国庆多呆一天</p>\n</blockquote>\n<h1>day1</h1>\n<p>提前好几天约的师傅不知道是睡过头了还是不想接我这一单，并没有来接我，校门口的黄色法拉利也不见了，只剩下了黑车。一辆车 8 个人，好在价格也没有多离谱，也按时到了火车站</p>\n<p>长沙比武汉近，6 个小时左右，在下午 3 点就到长沙了</p>\n<p>这次吸取武汉的教训，把酒店定在了地铁旁边，还就在高铁站附近</p>\n<Image src={room} alt=\"房间\" \n      sizes=\"100vw\"\n      style={{\n        width: '100%',\n        height: 'auto',\n      }} />\n\n<p>中秋节晚上，五一广场的街上就已经爆满，到处都是网红店的宣传，可能就趁这几天涨涨业绩\n<Image src={jie} alt=\"五一广场\" \n      sizes=\"100vw\"\n      style={{\n        width: '100%',\n        height: 'auto',\n      }} /></p>\n<p>我们还是受不住各自宣传推销,走近了一家网红店吃小龙虾，但是最后选择了罗氏虾\n不过味道实在一般，甚至不如我妈煮的味道。价格却不一般，差不多 4 道菜就花掉 300 大洋\n<Image src={firstdinner} alt=\"靓虾二哥\" \n      sizes=\"100vw\"\n      style={{\n        width: '100%',\n        height: 'auto',\n      }} />\n<Image src={firstdinner2} alt=\"靓虾二哥\" \n      sizes=\"100vw\"\n      style={{\n        width: '100%',\n        height: 'auto',\n      }} />\n<Image src={firstdinner3} alt=\"靓虾二哥\" \n      sizes=\"100vw\"\n      style={{\n        width: '100%',\n        height: 'auto',\n      }} /></p>\n<hr />\n<p>吃完饭，散散步，一路走到杜甫江阁\n路上还被黑心手工艺人骗走 188，留下一幅<del>大众样</del>剪纸\n<Image src={pic} alt=\"188的剪纸\" \n      sizes=\"100vw\"\n      style={{\n        width: '100%',\n        height: 'auto',\n      }} /></p>\n<p>杜甫江阁有专门拍照的的，设备挺齐全，会教我们摆 pose，拍的照片质量高，价格还可以，和剪纸可以说是鲜明对比。</p>\n<p>如果自己有相机，估计也能拍出这样的图\n<Image src={me} alt=\"杜甫江阁\" \n      sizes=\"100vw\"\n      style={{\n        width: '100%',\n        height: 'auto',\n      }} />\n<Image src={love} alt=\"杜甫江阁\" \n      sizes=\"100vw\"\n      style={{\n        width: '100%',\n        height: 'auto',\n      }} /></p>\n<h1>day2</h1>\n<p>俩个人旅游，主打的就是睡到自然醒\n早餐也不可能出酒店吃\n早餐\n<Image src={breakfast} alt=\"10点的早餐\" \n      sizes=\"100vw\"\n      style={{\n        width: '100%',\n        height: 'auto',\n      }} />\n中午逛完博物馆，其实也就看了两个展厅，反正门票不用钱\n直接回酒店吃午餐（外卖）\n午餐\n<Image src={lunch} alt=\"主打的就是丰富\" \n      sizes=\"100vw\"\n      style={{\n        width: '100%',\n        height: 'auto',\n      }} />\n休整一下</p>\n<p>晚上去了杨帆夜市，唯二两顿不在酒店吃的正餐\n全国美食街估计都这个味道，就只是去凑凑热闹\n<Image src={yeshi} alt=\"杨帆夜市\" \n      sizes=\"100vw\"\n      style={{\n        width: '100%',\n        height: 'auto',\n      }} />\n<Image src={yeshi2} alt=\"杨帆夜市\" \n      sizes=\"100vw\"\n      style={{\n        width: '100%',\n        height: 'auto',\n      }} />\n<Image src={yeshi3} alt=\"杨帆夜市\" \n      sizes=\"100vw\"\n      style={{\n        width: '100%',\n        height: 'auto',\n      }} />\n<Image src={tea} alt=\"杨帆夜市\" \n      sizes=\"100vw\"\n      style={{\n        width: '100%',\n        height: 'auto',\n      }} />\n<Image src={milk} alt=\"杨帆夜市\" \n      sizes=\"100vw\"\n      style={{\n        width: '100%',\n        height: 'auto',\n      }} />\n逛完美食街还早，想着去渔人码头又太远，就又绕去五一广场了。\n可惜文和友要排队而且人很多，在外面看了看，和福州的 M17 广场差不了太多，就算了</p>\n<p>夜市没吃饱，少不了夜宵\n<Image src={yexiao1} alt=\"一天四顿\" \n      sizes=\"100vw\"\n      style={{\n        width: '100%',\n        height: 'auto',\n      }} /></p>\n<h1>day3</h1>\n<p>git\n早上出门晚 ，差点进不去橘子洲头,12 点的票，11 点 57 分进去\n<Image src={icecream} alt=\"每个景区都少不了的纪念雪糕，不如武汉的好吃\" \n      sizes=\"100vw\"\n      style={{\n        width: '100%',\n        height: 'auto',\n      }} /></p>\n<Image src={lover_back} alt=\"江边健身道\" \n      sizes=\"100vw\"\n      style={{\n        width: '100%',\n        height: 'auto',\n      }} />\n\n<Image src={laomao} alt=\"青年毛\" \n      sizes=\"100vw\"\n      style={{\n        width: '100%',\n        height: 'auto',\n      }} />\n\n<p>走到腿断掉,果断选择酒店看电影</p>\n<p>晚上的渔人码头，没有想象中的那么好，就是一个靠江边吃小龙虾的地方，甚至不如夜市，如果人多来聚一聚吃个龙虾也不错\n<Image src={seaandyou} alt=\"江边美女\" \n      sizes=\"100vw\"\n      style={{\n        width: '100%',\n        height: 'auto',\n      }} /></p>\n<Image src={ciba} alt=\"加了红糖的糍粑罢了\" \n      sizes=\"100vw\"\n      style={{\n        width: '100%',\n        height: 'auto',\n      }} />\n\n<h1>day4</h1>\n<p>快乐的时光总是很短暂，离别从来都很伤感，四天三夜还是太快</p>\n<p>8 天的假期，应该玩上 5 天 4 夜的</p>\n<Image src={lastlunch} alt=\"最后一顿\" \n      sizes=\"100vw\"\n      style={{\n        width: '100%',\n        height: 'auto',\n      }} />\n\n<hr />\n<p>其实长沙没武汉大，从地铁就能看出来，但我感觉玩的比武汉开心，可能在吃这一方面比上次武汉吃的多得多，基本每一天晚上都吃了夜宵\n靠地铁近，不用每次都打车也省下了一笔交通费</p>\n","id":"17"},{"title":"TheFirstRedrockProject","date":"2023-09-18","excerpt":"The First Project,the first step","categories":"Project","html":"<blockquote>\n<p>第一个团队合作项目</p>\n</blockquote>\n<p>收获：</p>\n<ul>\n<li>git</li>\n<li>团队协作</li>\n</ul>\n<p><a href=\"http://fe-prod.redrock.cqupt.edu.cn/venue-application-backstage/\">项目地址</a></p>\n<h1>技术栈</h1>\n<ol>\n<li>React</li>\n<li>Typescript</li>\n<li>Vite</li>\n<li>Recoil</li>\n<li>ANTD</li>\n<li>Mock</li>\n<li>module.less</li>\n<li>pnpm</li>\n</ol>\n<h1>拆分模块</h1>\n<ol>\n<li><p>其余场地申请</p>\n<ul>\n<li>申请列表</li>\n<li>时间表</li>\n</ul>\n</li>\n<li><p>科技会堂场地申请 - 申请列表 - 时间表</p>\n</li>\n</ol>\n<p>二者差异不大，主要是在一些弹窗以及内容上的区别</p>\n<h1>实现思路</h1>\n<ul>\n<li>申请列表：</li>\n</ul>\n<ol>\n<li>接受后端传的 data，通过 ANTD 渲染表格。</li>\n<li>不同状态的场地的筛选就是对 data 筛选完成为新的 data 通通过 ANTD 渲染。</li>\n<li>搜索同理，注意就是搜索要在不同状态的场地筛选完的新 data 再搜索筛选。</li>\n<li>详情弹窗就是点击详情将这一条数据传递给弹窗组件。</li>\n</ol>\n<ul>\n<li>时间表：</li>\n</ul>\n<ol>\n<li>时间表稍微有难度一点，首先是表格没有使用 ANTD，使用原生的 table 和 tr td 标签</li>\n<li>将每块场地为每一行的行头，将当天的每一段时间作为每一列的列头。</li>\n<li>然后是表格内容的数据的处理，以其余场地申请为例子，是通过日期查询当天的场地申请数据，然后进行数据的处理，将某块场地设为 parent，他全部时间段设为一个 children，里面的每一个 child 通过申请的或者待审批的就是被占用的，flag 为 ture，其余的为 flase，条件渲染到表格中。</li>\n<li>再对每一个表格格子做一点动画，也以其余场地申请为例子，鼠标移入出现编辑图标，移除图标消失，点击图标出现编辑弹窗，传入选中时间以及场地，以及其他需要编辑的表单。</li>\n<li>点击占用的部分，跳出详情弹窗，内容为当前格的数据</li>\n<li>科技会堂申请的时间表有些许不同，每一行的行头是日期，列头也是每段时间，时间段也不同，只用对数据处理做一些修改。</li>\n<li>鼠标移入移除动画也不同，是点击移动相应的表格颜色变化，松开跳出编辑弹窗。</li>\n</ol>\n<p>难点：\n一个在于 ts 的运用，数据类型麻烦且多，需要仔细琢磨不然很容易出错\n二个就是对原生表格的运用，时间表数据的处理也是一大难点</p>\n","id":"5"},{"title":"武汉之行","date":"2023-05-03","categories":"Life","excerpt":"故人西辞黄鹤楼，烟花三月下扬州。孤帆远影碧空尽，唯见长江天际流。","html":"<blockquote>\n<p>人真的多多多，酒店真的远远远；希望下次能避开大假期，酒店定的<del>贵一点</del>好一点</p>\n</blockquote>\n<h1>Day1</h1>\n<p>早上八点快九点的动车，5 点钟我就从学校出发了\n昨天买的零食还丢在了车上，硬生生饿七个多小时到武汉</p>\n<Image src={day1_station} alt=\"\" \n      sizes=\"100vw\"\n      style={{\n        width: '100%',\n        height: 'auto',\n      }} />\n人多到 6 点排队吃小龙虾要排上 130 桌，换了一家偏僻角落的店铺才能吃上。\n\n<Image src={feifeixiazhuang} alt=\"肥肥虾庄\" \n      sizes=\"100vw\"\n      style={{\n        width: '100%',\n        height: 'auto',\n      }} />\n\n<p>吃完饭坐上了轮渡，一路坐到长江大桥桥下。</p>\n<Image src={me_girlfriend} alt=\"轮渡上合照一张\" \n      sizes=\"100vw\"\n      style={{\n        width: '100%',\n        height: 'auto',\n      }} />\n\n<p>从船上看长江大桥不如在路上看</p>\n<Image src={bridge0} alt=\"桥头小亭子\" \n      sizes=\"100vw\"\n      style={{\n        width: '100%',\n        height: 'auto',\n      }} />\n<Image src={bridge1} alt=\"长江大桥\" \n      sizes=\"100vw\"\n      style={{\n        width: '100%',\n        height: 'auto',\n      }} />\n\n<h1>Day2</h1>\n<p>来武汉听说不能不过早\n兰陵路离我们酒店算最近的(一样很远)\n武汉本地热干面真的和别的地方的武汉热干面不一样，香太多了。</p>\n<Image src={guozao1} alt=\"热干面，烧卖，绿豆汤\" \n      sizes=\"100vw\"\n      style={{\n        width: '100%',\n        height: 'auto',\n      }} />\n这家三鲜豆皮不好吃\n\n<Image src={guozao2} alt=\"三鲜豆皮\" \n      sizes=\"100vw\"\n      style={{\n        width: '100%',\n        height: 'auto',\n      }} />\n\n<p>下午去了古德寺，和以前去过的寺庙不太一样，带有点欧洲的风格。</p>\n<Image src={gude} alt=\"古德寺\" \n      sizes=\"100vw\"\n      style={{\n        width: '100%',\n        height: 'auto',\n      }} />\n一根 15，还不错的景区特色雪糕\n\n<Image src={gudexuegao} alt=\"古德寺特色雪糕\" \n      sizes=\"100vw\"\n      style={{\n        width: '100%',\n        height: 'auto',\n      }} />\n\n<p>本来打算再去长江大桥上看看日落，低估了我们的行进速度，美美的在路上看着太阳落下。</p>\n<Image src={jianghang} alt=\"路经江汉桥\" \n      sizes=\"100vw\"\n      style={{\n        width: '100%',\n        height: 'auto',\n      }} />\n\n<p>而且今晚的人流量，少说也有昨天的 2 倍。大桥上黑压压的都是人，根本没法走。\n想挤地铁回家，误打误撞挤到户部巷中。\n扭头买个冰粉，直接堵在巷中出都出不来。</p>\n<Image src={day2_night1} alt=\"就扭了个头买冰粉\" \n      sizes=\"100vw\"\n      style={{\n        width: '100%',\n        height: 'auto',\n      }} />\n\n<p>原来这边是拍黄鹤楼的绝美点，难怪挤死了</p>\n<Image src={huanghelou} alt=\"封面来源\" \n      sizes=\"100vw\"\n      style={{\n        width: '100%',\n        height: 'auto',\n      }} />\n\n<h1>Day3</h1>\n<p>早上要换酒店，干脆睡吃一点，在酒店过早了</p>\n<Image src={day3_m} alt=\"锅贴，热干面，绿豆汤米酒和燕麦豆浆\" \n      sizes=\"100vw\"\n      style={{\n        width: '100%',\n        height: 'auto',\n      }} />\n\n<p>下午去东湖，坐地铁转了无数个站，在下午太阳最大的时候来到了东湖\n原来省博和省美术馆也在这里，可惜没预约也进不去</p>\n<Image src={donhu1} alt=\"东湖\" \n      sizes=\"100vw\"\n      style={{\n        width: '100%',\n        height: 'auto',\n      }} />\n<Image src={donhu2} alt=\"屈原纪念馆\" \n      sizes=\"100vw\"\n      style={{\n        width: '100%',\n        height: 'auto',\n      }} />\n<Image src={donhu3} alt=\"美女在东湖\" \n      sizes=\"100vw\"\n      style={{\n        width: '100%',\n        height: 'auto',\n      }} />\n\n<p>挺讨厌吃饭要排队的，但楚采这家店上的快，价格便宜，主要是好吃，特别是虾和红烧肉。\n可惜在五一踩着开门的时间去排队也得等上一个小时。</p>\n<Image src={cha} alt=\"心心念念的茶颜悦色\" \n      sizes=\"100vw\"\n      style={{\n        width: '100%',\n        height: 'auto',\n      }} />\n<Image src={chucai1} alt=\"楚采的红烧肉\" \n      sizes=\"100vw\"\n      style={{\n        width: '100%',\n        height: 'auto',\n      }} />\n<Image src={chucai2} alt=\"楚采的虾\" \n      sizes=\"100vw\"\n      style={{\n        width: '100%',\n        height: 'auto',\n      }} />\n\n<p>吃完去中山公园散个步</p>\n<Image src={zhongshan} alt=\"路过旋转木马\" \n      sizes=\"100vw\"\n      style={{\n        width: '100%',\n        height: 'auto',\n      }} />\n<Image src={together} alt=\"合照\" \n      sizes=\"100vw\"\n      style={{\n        width: '100%',\n        height: 'auto',\n      }} />\n\n<p>四天武汉之行就要结束咯</p>\n<h1>Day4</h1>\n<p>下次车票订一个站，时间差不多，不然分开太痛苦了，又在车站等三个多小时才上车</p>\n<p>回到重庆太晚了，在学长的别墅留宿一晚</p>\n<h1>总结</h1>\n<p>看来我俩旅游不适合特种兵玩法，就喜欢吃吃吃，不喜欢走走走\n酒店别因为便宜就定在鸟不拉屎的地方，啥也没有打车费还高，加上打车费和位置好的酒店价格没差\n人实在太多，大伙疫情关了 3 年，现在刚放开的一个小长假，出行人数简直爆炸，希望下次能避开高峰期</p>\n","id":"16"}] 
        module.exports = {
            DATA,
          };
          